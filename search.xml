<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你好，世界！</title>
    <url>/2020/08/21/hello-world/</url>
    <content><![CDATA[<h4 id="我是百川！"><a href="#我是百川！" class="headerlink" title="我是百川！"></a>我是百川！</h4><p>over！</p>
<p>欢迎来到万海！</p>
]]></content>
  </entry>
  <entry>
    <title>swap分区详解与使用</title>
    <url>/2020/08/25/swap%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="swap分区详解"><a href="#swap分区详解" class="headerlink" title="swap分区详解"></a>swap分区详解</h2><p>我们在安装系统的时候已经建立了 swap 分区。swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间。</p>
<p> 也就是说，当内存不够用时，我们使用 swap 分区来临时顶替。这种“拆东墙，补西墙”的方式应用于几乎所有的操作系统中。</p>
<p> 使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比  RAM 要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是使用 swap 交换分区最大的限制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相比较而言，Windows 不会为 swap 单独划分一个分区，而是使用分页文件实现相同的功能，在概念上，Windows 称其为虚拟内存，从某种意义上将，这个叫法更容易理解。因此，初学者将 swap 交换分区理解为虚拟内存是没有任何问题的。</span><br></pre></td></tr></table></figure>

<p>具体使用多大的 swap 分区，取决于物理内存大小和硬盘的容量。一般来讲，swap 分区容量应大于物理内存大小，建议是内存的两倍，但不超过  2GB。但是，有时服务器的访问量确实很大，有可能出现 swap 分区不够用的情况，所以我们需要学习 swap 分区的构建方法。</p>
<p> 建立新的 swap 分区，只需要执行以下几个步骤。</p>
<ol>
<li>分区：不管是 fdisk 命令还是 parted 命令，都需要先区。</li>
<li>格式化：格式化命令稍有不同，使用 mkswap 命令把分区格式化成 swap 分区。</li>
<li>使用 swap 分区。</li>
</ol>
<p> 下面我们来逐一实现。</p>
<h2 id="建立swap分区第一步：分区"><a href="#建立swap分区第一步：分区" class="headerlink" title="建立swap分区第一步：分区"></a>建立swap分区第一步：分区</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk &#x2F;dev&#x2F;sdb</span><br><span class="line">#以&#x2F;dev&#x2F;sdb分区为例</span><br><span class="line">WARNING: DOS-compatible mode is deprecated.It&#39;s strongly recommended to switch off the mode (command &#39;c&#39;) and change display units to sectors (command &#39;u&#39;).</span><br><span class="line">Command (m for help): n</span><br><span class="line">#新建</span><br><span class="line">Command action e extended p primary partition (1-4)</span><br><span class="line">P</span><br><span class="line">#主分区</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line">#分区编号</span><br><span class="line">First cylinder (1-2610, default 1):</span><br><span class="line">#起始柱面</span><br><span class="line">Using default value 1</span><br><span class="line">Last cylinder, +cylinders or +size&#123;K, M, G&#125; (1-2610, default 2610): +500M</span><br><span class="line">#大小</span><br><span class="line">Command (m for help): p</span><br><span class="line">#查看一下</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb: 21.5GB, 21474836480 bytes</span><br><span class="line">255 heads, 63 sectors&#x2F;track, 2610 cylinders</span><br><span class="line">Units &#x3D; cylinders of 16065 *512 &#x3D; 8225280 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes 1512 bytes</span><br><span class="line">Disk identifier: OxOOOOOebd</span><br><span class="line">Device Boot Start End Blocks Id System</span><br><span class="line">&#x2F;dev&#x2F;sdb1 1 65 522081 83 Linux</span><br><span class="line">#刚分配的分区ID是83，是Linux分区，我们在这里要分配swap分区</span><br><span class="line">Command (m for help): t</span><br><span class="line">#修改分区的系统ID</span><br><span class="line">Selected partition 1</span><br><span class="line">#只有一个分区，所以不用选择分区了</span><br><span class="line">Hex code (type L to list codes): 82</span><br><span class="line">#改为swap分区的ID</span><br><span class="line">Changed system type of partition 1 to 82 (Linux swap &#x2F; Solaris)</span><br><span class="line">Command (m for help): p</span><br><span class="line">#再查看一下</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb: 21.5 GB, 21474836480 bytes</span><br><span class="line">255 heads, 63 sectors&#x2F;track, 2610 cylinders</span><br><span class="line">Units &#x3D; cylinders of 16065 *512 &#x3D; 8225280 bytes Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes I&#x2F;O size (minimum&#x2F;optimal): 512 bytes 1512 bytes Disk identifier: OxOOOOOebd</span><br><span class="line">Device Boot Start End Blocks Id System</span><br><span class="line">&#x2F;dev&#x2F;sdb1 1 65 522081 82 Linux swap &#x2F; Solaris</span><br><span class="line">#修改过来了</span><br><span class="line">Command (m for help): w</span><br><span class="line">#记得保存退出</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<p>仍以 /dev/sdb 分区作为实验对象。不过，如果分区刚刚使用 parted 命令转变为 GPT 分区表，则记得转换回 MBR 分区表，fdisk 命令才能识别，否则干脆新添加一块硬盘做实验。</p>
<h2 id="建立-swap-分区第二步：格式化"><a href="#建立-swap-分区第二步：格式化" class="headerlink" title="建立 swap 分区第二步：格式化"></a>建立 swap 分区第二步：格式化</h2><p>因为要格式化成 swap 分区，所以格式化命令是 mkswap。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkswap &#x2F;dev&#x2F;sdb1</span><br><span class="line">Setting up swapspace version 1, size &#x3D; 522076 KiB</span><br><span class="line">no label, UUID&#x3D;c3351 dc3-f403-419a-9666-c24615e170fb</span><br></pre></td></tr></table></figure>

<h2 id="使用swap分区"><a href="#使用swap分区" class="headerlink" title="使用swap分区"></a>使用swap分区</h2><p>在使用 swap 分区之前，我们先来说说 free 命令。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#free</span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 1030796 130792 900004 0 15292 55420</span><br><span class="line">-&#x2F;+ buffers&#x2F;cache: 60080 970716</span><br><span class="line">Swap: 2047992 0 2047992</span><br></pre></td></tr></table></figure>

<p>free 命令主要是用来查看内存和 swap 分区的使用情况的，其中：</p>
<ul>
<li>total：是指总数；</li>
<li>used：是指已经使用的；</li>
<li>free：是指空闲的；</li>
<li>shared：是指共享的；</li>
<li>buffers：是指缓冲内存数；</li>
<li>cached：是指缓存内存数，单位是KB；</li>
</ul>
<p>我们需要解释一下 buffers（缓冲）和 cached（缓存）的区别。简单来讲，cached 是给读取数据时加速的，buffers  是给写入数据加速的。cached  是指把读取出来的数据保存在内存中，当再次读取时，不用读取硬盘而直接从内存中读取，加速了数据的读取过程；buffers  是指在写入数据时，先把分散的写入操作保存到内存中，当达到一定程度后再集中写入硬盘，减少了磁盘碎片和硬盘的反复寻道，加速了数据的写入过程。</p>
<p> 我们已经看到，在加载进新的 swap 分区之前，swap 分区的大小是 2000MB，接下来只要加入 swap 分区就可以了，使用命令 swapon。命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# swapon 分区设备文件名</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# swapon &#x2F;dev&#x2F;sdb1</span><br><span class="line">swap分区已加入，我们查看一下。</span><br><span class="line">[root@localhost ~]#free</span><br><span class="line">total used free shared buffers cached</span><br><span class="line">Mem: 1030796 131264 899532 0 15520 55500</span><br><span class="line">-&#x2F;+ buffers&#x2F;cache: 60244 970552</span><br><span class="line">Swap: 2570064 0 2570064</span><br></pre></td></tr></table></figure>

<p>swap 分区的大小变成了 2500MB，加载成功了。如果要取消新加入的 swap 分区，则也很简单，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# swapoff &#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure>

<p>如果想让 swap 分区开机之后自动挂载，就需要修改 /etc/fstab 文件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#vi &#x2F;etc&#x2F;fstab</span><br><span class="line">UUID&#x3D;c2ca6f57-b15c-43ea-bca0-f239083d8bd2 &#x2F; ext4 defaults 1 1</span><br><span class="line">UUID&#x3D;0b23d315-33a7-48a4-bd37-9248e5c443451 boot ext4 defaults 1 2</span><br><span class="line">UUID&#x3D;4021be19-2751-4dd2-98cc-383368c39edb swap swap defaults 0 0</span><br><span class="line">tmpfs &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs defaults 0 0</span><br><span class="line">devpts &#x2F;dev&#x2F;pts</span><br><span class="line">devpts gid&#x3D;5, mode&#x3D;620 0 0</span><br><span class="line">sysfs &#x2F;sys</span><br><span class="line">sysfs defaults 0 0</span><br><span class="line">proc &#x2F;proc</span><br><span class="line">proc defaults 0 0</span><br><span class="line">&#x2F;dev&#x2F;sdb1 swap swap</span><br><span class="line">defaults 0 0</span><br><span class="line">#加入新swap分区的相关内容，这里直接使用分区的设备文件名，也可以使用UUID。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>swap分区详解与使用</category>
      </categories>
      <tags>
        <tag>swap分区详解与使用</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK企业实战</title>
    <url>/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="ELK-kafka-filebeat企业内部日志分析系统"><a href="#ELK-kafka-filebeat企业内部日志分析系统" class="headerlink" title="ELK+kafka+filebeat企业内部日志分析系统"></a>ELK+kafka+filebeat企业内部日志分析系统</h2><p>  <strong>elk:日志搜集平台</strong></p>
<p>ELK由ElasticSearch、Logstash和Kibana三个开源工具组成：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1565095105964.png" alt="1565095105964"></p>
<h3 id="1、组件介绍"><a href="#1、组件介绍" class="headerlink" title="1、组件介绍"></a>1、组件介绍</h3><h4 id="1、Elasticsearch："><a href="#1、Elasticsearch：" class="headerlink" title="1、Elasticsearch："></a>1、Elasticsearch：</h4><p> ElasticSearch是一个基于Lucene的开源分布式搜索服务。<strong>只搜索和分析日志</strong></p>
<p><strong>特点：分布式，零配置，自动发现，索引自动分片，索引副本机制，多数据源等</strong>。它提供了一个分布式多用户能力的全文搜索引擎。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是第二流行的企业搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。<br>在elasticsearch中，所有节点的数据是均等的。</p>
<p>索引：</p>
<p>索引（库）–&gt;类型（表）–&gt;文档（记录）</p>
<h4 id="2、Logstash"><a href="#2、Logstash" class="headerlink" title="2、Logstash:"></a>2、Logstash:</h4><p> Logstash是一个完全开源工具，可以对你的日志进行收集、过滤、分析，并将其存储供以后使用（如，搜索），logstash带有一个web界面，搜索和展示所有日志。  <strong>只收集和过滤日志,和改格式</strong></p>
<p>简单来说logstash就是一根具备实时数据传输能力的管道，负责将数据信息从管道的输入端传输到管道的输出端；与此同时这根管道还可以让你根据自己的需求在中间加上滤网，Logstash提供很多功能强大的滤网以满足你的各种应用场景。</p>
<p>② Logstash的事件（logstash将数据流中等每一条数据称之为一个event）处理流水线有三个主要角色完成：inputs –&gt; filters –&gt; outputs：</p>
<p><strong>logstash整个工作流分为三个阶段：输入、过滤、输出。每个阶段都有强大的插件提供支持</strong>：</p>
<p><strong>Input 必须，负责产生事件（Inputs generate events）,常用的插件有</strong>    </p>
<ul>
<li>file 从文件系统收集数据</li>
<li>syslog 从syslog日志收集数据</li>
<li>redis 从redis收集日志</li>
<li>beats 从beats family收集日志（如：Filebeats）</li>
</ul>
<p><strong>Filter常用的插件，负责数据处理与转换（filters modify them）</strong></p>
<ul>
<li>grok是logstash中最常用的日志解释和结构化插件。：grok是一种采用组合多个预定义的正则表达式，用来匹配分割文本并映射到关键字的工具。</li>
<li>mutate 支持事件的变换，例如重命名、移除、替换、修改等</li>
<li>drop 完全丢弃事件</li>
<li>clone 克隆事件</li>
</ul>
<p><strong>output 输出,必须，负责数据输出（outputs ship them elsewhere）,常用的插件有</strong></p>
<ul>
<li>elasticsearch 把数据输出到elasticsearch</li>
<li>file 把数据输出为普通的文件</li>
</ul>
<h4 id="3、Kibana"><a href="#3、Kibana" class="headerlink" title="3、Kibana:"></a>3、Kibana:</h4><p>Kibana 是一个基于浏览器页面的Elasticsearch前端展示工具，也是一个开源和免费的工具，Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮你汇总、分析和搜索重要数据日志。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1565095431120.png" alt="1565095431120"></p>
<h3 id="2、环境介绍"><a href="#2、环境介绍" class="headerlink" title="2、环境介绍"></a>2、环境介绍</h3><table>
<thead>
<tr>
<th>安装软件</th>
<th align="center">主机名</th>
<th align="center">IP地址</th>
<th align="center">系统版本</th>
</tr>
</thead>
<tbody><tr>
<td>Elasticsearch/</td>
<td align="center">mes-1-zk</td>
<td align="center">192.168.246.234</td>
<td align="center">centos7.4–3G</td>
</tr>
<tr>
<td>zookeeper/kafka/Logstash</td>
<td align="center">es-2-zk-log</td>
<td align="center">192.168.246.231</td>
<td align="center">centos7.4–2G</td>
</tr>
<tr>
<td>head/Kibana</td>
<td align="center">es-3-head-kib-zk-File</td>
<td align="center">192.168.246.235</td>
<td align="center">centos7.4—2G</td>
</tr>
<tr>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>所有机器关闭防火墙，selinux</p>
<h3 id="3、版本说明"><a href="#3、版本说明" class="headerlink" title="3、版本说明"></a>3、版本说明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Elasticsearch: 6.5.4  #https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.5.4.tar.gz</span><br><span class="line">Logstash: 6.5.4  #https://artifacts.elastic.co/downloads/logstash/logstash-6.5.4.tar.gz</span><br><span class="line">Kibana: 6.5.4  #https://artifacts.elastic.co/downloads/kibana/kibana-6.5.4-linux-x86_64.tar.gz</span><br><span class="line">Kafka: 2.11-2.1  #https://archive.apache.org/dist/kafka/2.1.0/kafka_2.11-2.1.0.tgz</span><br><span class="line">Filebeat: 6.5.4</span><br><span class="line">相应的版本最好下载对应的插件</span><br></pre></td></tr></table></figure>

<p>相关地址：</p>
<p>官网地址：<a href="https://www.elastic.co/">https://www.elastic.co</a></p>
<p>官网搭建：<a href="https://www.elastic.co/guide/index.html">https://www.elastic.co/guide/index.html</a></p>
<h3 id="实施部署"><a href="#实施部署" class="headerlink" title="实施部署"></a>实施部署</h3><h4 id="1、-Elasticsearch部署"><a href="#1、-Elasticsearch部署" class="headerlink" title="1、 Elasticsearch部署"></a>1、 Elasticsearch部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">系统类型：Centos7.5</span><br><span class="line">节点IP：172.16.246.234</span><br><span class="line">软件版本：jdk-8u191-linux-x64.tar.gz、elasticsearch-6.5.4.tar.gz</span><br><span class="line">示例节点：172.16.246.234  ABC</span><br></pre></td></tr></table></figure>

<h5 id="1、安装配置jdk8"><a href="#1、安装配置jdk8" class="headerlink" title="1、安装配置jdk8"></a>1、安装配置jdk8</h5><p>ES运行依赖jdk8   —–三台机器都操作，先上传jdk1.8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# tar xzf jdk-8u191-linux-x64.tar.gz -C /usr/local/</span><br><span class="line">[root@mes-1 ~]# cd /usr/local/</span><br><span class="line">[root@mes-1 local]# mv jdk1.8.0_191/ java</span><br><span class="line">[root@mes-1 local]# echo &#x27;</span><br><span class="line">JAVA_HOME=/usr/local/java</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH</span><br><span class="line">&#x27; &gt;&gt;/etc/profile</span><br><span class="line">[root@mes-1 ~]# source /etc/profile</span><br><span class="line">[root@mes-1  local]# java -version</span><br><span class="line">java version &quot;1.8.0_211&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<h5 id="2、安装配置ES—-只在第一台操作操作下面的部分"><a href="#2、安装配置ES—-只在第一台操作操作下面的部分" class="headerlink" title="2、安装配置ES—-只在第一台操作操作下面的部分"></a>2、安装配置ES—-只在第一台操作操作下面的部分</h5><h6 id="（1）创建运行ES的普通用户"><a href="#（1）创建运行ES的普通用户" class="headerlink" title="（1）创建运行ES的普通用户"></a>（1）创建运行ES的普通用户</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# useradd elsearch</span><br><span class="line">[root@mes-1 ~]# echo &quot;123456&quot; | passwd --stdin &quot;elsearch&quot;</span><br></pre></td></tr></table></figure>

<h6 id="（2）安装配置ES"><a href="#（2）安装配置ES" class="headerlink" title="（2）安装配置ES"></a>（2）安装配置ES</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# tar xzf elasticsearch-6.5.4.tar.gz -C /usr/local/</span><br><span class="line">[root@mes-1 ~]# cd /usr/local/elasticsearch-6.5.4/config/</span><br><span class="line">[root@mes-1 config]# ls</span><br><span class="line">elasticsearch.yml  log4j2.properties  roles.yml  users_roles</span><br><span class="line">jvm.options        role_mapping.yml   users</span><br><span class="line">[root@mes-1 config]# cp elasticsearch.yml elasticsearch.yml.bak</span><br><span class="line">[root@mes-1 config]# vim elasticsearch.yml    ----找个地方添加如下内容</span><br><span class="line">cluster.name: elk</span><br><span class="line">node.name: elk01</span><br><span class="line">node.master: true</span><br><span class="line">node.data: true</span><br><span class="line">path.data: /data/elasticsearch/data</span><br><span class="line">path.logs: /data/elasticsearch/logs</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.ping.unicast.hosts: [<span class="string">&quot;192.168.246.234&quot;</span>, <span class="string">&quot;192.168.246.231&quot;</span>,<span class="string">&quot;192.168.246.235&quot;</span>]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.minimum_master_nodes: 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.ping_timeout: 150s</span></span><br><span class="line"><span class="meta">#</span><span class="bash">discovery.zen.fd.ping_retries: 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash">client.transport.ping_timeout: 60s</span></span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>

<p>配置项含义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster.name        集群名称，各节点配成相同的集群名称。</span><br><span class="line">node.name       节点名称，各节点配置不同。</span><br><span class="line">node.master     指示某个节点是否符合成为主节点的条件。</span><br><span class="line">node.data       指示节点是否为数据节点。数据节点包含并管理索引的一部分。</span><br><span class="line">path.data       数据存储目录。</span><br><span class="line">path.logs       日志存储目录。</span><br><span class="line">bootstrap.memory_lock       内存锁定，是否禁用交换。</span><br><span class="line">bootstrap.system_call_filter    系统调用过滤器。</span><br><span class="line">network.host    绑定节点IP。</span><br><span class="line">http.port       端口。</span><br><span class="line">discovery.zen.ping.unicast.hosts    提供其他 Elasticsearch 服务节点的单点广播发现功能。</span><br><span class="line">discovery.zen.minimum_master_nodes  集群中可工作的具有Master节点资格的最小数量，官方的推荐值是(N/2)+1，其中N是具有master资格的节点的数量。</span><br><span class="line">discovery.zen.ping_timeout      节点在发现过程中的等待时间。</span><br><span class="line">discovery.zen.fd.ping_retries        节点发现重试次数。</span><br><span class="line">http.cors.enabled               是否允许跨源 REST 请求，用于允许head插件访问ES。</span><br><span class="line">http.cors.allow-origin              允许的源地址。</span><br></pre></td></tr></table></figure>

<h6 id="（3）设置JVM堆大小"><a href="#（3）设置JVM堆大小" class="headerlink" title="（3）设置JVM堆大小"></a>（3）设置JVM堆大小</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 config]# vim jvm.options     ----将</span><br><span class="line">-Xms1g    ----修改成 -Xms2g</span><br><span class="line">-Xmx1g    ----修改成 -Xms2g</span><br><span class="line"></span><br><span class="line">或者:</span><br><span class="line">推荐设置为4G，请注意下面的说明：</span><br><span class="line">sed -i &#x27;s/-Xms1g/-Xms4g/&#x27; /usr/local/elasticsearch-6.5.4/config/jvm.options</span><br><span class="line">sed -i &#x27;s/-Xmx1g/-Xmx4g/&#x27; /usr/local/elasticsearch-6.5.4/config/jvm.options</span><br></pre></td></tr></table></figure>

<p>注意：<br>确保堆内存最小值（Xms）与最大值（Xmx）的大小相同，防止程序在运行时改变堆内存大小。<br>堆内存大小不要超过系统内存的50%</p>
<h6 id="（4）创建ES数据及日志存储目录"><a href="#（4）创建ES数据及日志存储目录" class="headerlink" title="（4）创建ES数据及日志存储目录"></a>（4）创建ES数据及日志存储目录</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# mkdir -p /data/elasticsearch/data       (/data/elasticsearch)</span><br><span class="line">[root@mes-1 ~]# mkdir -p /data/elasticsearch/logs       (/log/elasticsearch)</span><br></pre></td></tr></table></figure>

<h6 id="（5）修改安装目录及存储目录权限"><a href="#（5）修改安装目录及存储目录权限" class="headerlink" title="（5）修改安装目录及存储目录权限"></a>（5）修改安装目录及存储目录权限</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# chown -R elsearch:elsearch /data/elasticsearch</span><br><span class="line">[root@mes-1 ~]# chown -R elsearch:elsearch /usr/local/elasticsearch-6.5.4</span><br></pre></td></tr></table></figure>

<h5 id="3、系统优化"><a href="#3、系统优化" class="headerlink" title="3、系统优化"></a>3、系统优化</h5><h6 id="（1）增加最大文件打开数"><a href="#（1）增加最大文件打开数" class="headerlink" title="（1）增加最大文件打开数"></a>（1）增加最大文件打开数</h6><p>永久生效方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;* - nofile 65536&quot; &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>



<h6 id="（2）增加最大进程数"><a href="#（2）增加最大进程数" class="headerlink" title="（2）增加最大进程数"></a>（2）增加最大进程数</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# vim &#x2F;etc&#x2F;security&#x2F;limits.conf    ---在文件最后面添加如下内容</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br><span class="line">更多的参数调整可以直接用这个</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">soft  xxx  : 代表警告的设定，可以超过这个设定值，但是超过后会有警告。</span><br><span class="line">hard  xxx  : 代表严格的设定，不允许超过这个设定的值。</span><br><span class="line">nofile : 是每个进程可以打开的文件数的限制</span><br><span class="line">nproc  : 是操作系统级别对每个用户创建的进程数的限制</span><br></pre></td></tr></table></figure>



<h6 id="（3）增加最大内存映射数"><a href="#（3）增加最大内存映射数" class="headerlink" title="（3）增加最大内存映射数"></a>（3）增加最大内存映射数</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# vim /etc/sysctl.conf   ---添加如下</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line">vm.swappiness=0</span><br><span class="line">[root@mes-1 ~]# sysctl -p</span><br><span class="line">解释：在内存不足的情况下，使用交换空间。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@mes-1 ~]# sysctl -w vm.max_map_count=262144</span><br><span class="line">增大用户使用内存的空间(临时)</span><br></pre></td></tr></table></figure>

<p>启动如果报下列错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">memory locking requested for elasticsearch process but memory is not locked</span><br><span class="line">elasticsearch.yml文件</span><br><span class="line">bootstrap.memory_lock : false</span><br><span class="line">/etc/sysctl.conf文件</span><br><span class="line">vm.swappiness=0</span><br><span class="line"></span><br><span class="line">错误:</span><br><span class="line">max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br><span class="line"></span><br><span class="line">意思是elasticsearch用户拥有的客串建文件描述的权限太低，知道需要65536个</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">切换到root用户下面，</span><br><span class="line"></span><br><span class="line">vim   /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">在最后添加</span><br><span class="line">* hard nofile 65536</span><br><span class="line">* hard nofile 65536</span><br><span class="line">重新启动elasticsearch，还是无效？</span><br><span class="line">必须重新登录启动elasticsearch的账户才可以，例如我的账户名是elasticsearch，退出重新登录。</span><br><span class="line">另外*也可以换为启动elasticsearch的账户也可以，* 代表所有，其实比较不合适</span><br><span class="line"></span><br><span class="line">启动还会遇到另外一个问题，就是</span><br><span class="line">max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br><span class="line">意思是：elasticsearch用户拥有的内存权限太小了，至少需要262114。这个比较简单，也不需要重启，直接执行</span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl -w vm.max_map_count=262144</span></span><br><span class="line">就可以了</span><br></pre></td></tr></table></figure>

<h5 id="4、启动ES"><a href="#4、启动ES" class="headerlink" title="4、启动ES"></a>4、启动ES</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# su - elsearch</span><br><span class="line">Last login: Sat Aug  3 19:48:59 CST 2019 on pts/0</span><br><span class="line">[root@mes-1 ~]$ cd /usr/local/elasticsearch-6.5.4/</span><br><span class="line">[root@mes-1 elasticsearch-6.5.4]$ ./bin/elasticsearch  #先启动看看报错不，需要多等一会</span><br><span class="line">终止之后</span><br><span class="line">[root@mes-1 elasticsearch-6.5.4]$ nohup ./bin/elasticsearch &amp;  #放后台启动</span><br><span class="line">[1] 11462</span><br><span class="line">nohup: ignoring input and appending output to ‘nohup.out’</span><br><span class="line">[root@mes-1 elasticsearch-6.5.4]$ tail -f nohup.out   #看一下是否启动</span><br><span class="line">或者:</span><br><span class="line">su - elsearch -c &quot;cd /usr/local/elasticsearch-6.5.4 &amp;&amp; nohup bin/elasticsearch &amp;&quot;</span><br></pre></td></tr></table></figure>

<p>测试：浏览器访问<a href="http://172.16.246.234:9200/">http://172.16.246.234:9200</a><br><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564833955701.png" alt="1564833955701"></p>
<h5 id="5-安装配置head监控插件（Web前端）—-只需要安装一台就可以了。192-168-246-235"><a href="#5-安装配置head监控插件（Web前端）—-只需要安装一台就可以了。192-168-246-235" class="headerlink" title="5.安装配置head监控插件（Web前端）—-只需要安装一台就可以了。192.168.246.235"></a>5.安装配置head监控插件（Web前端）—-只需要安装一台就可以了。192.168.246.235</h5><h6 id="（1）安装node"><a href="#（1）安装node" class="headerlink" title="（1）安装node"></a>（1）安装node</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# wget https://npm.taobao.org/mirrors/node/latest-v4.x/node-v4.4.7-linux-x64.tar.gz</span><br><span class="line">[root@es-3-head-kib ~]# tar -zxf node-v4.4.7-linux-x64.tar.gz –C /usr/local</span><br><span class="line">[root@es-3-head-kib ~]# vim /etc/profile   #添加如下变量</span><br><span class="line">NODE_HOME=/usr/local/node-v4.4.7-linux-x64</span><br><span class="line">PATH=$NODE_HOME/bin:$PATH</span><br><span class="line">export NODE_HOME PATH</span><br><span class="line">[root@es-3-head-kib ~]# source /etc/profile</span><br><span class="line">[root@es-3-head-kib ~]# node --version  #检查node版本号</span><br><span class="line">v4.4.7</span><br></pre></td></tr></table></figure>

<h6 id="（2）下载head插件"><a href="#（2）下载head插件" class="headerlink" title="（2）下载head插件"></a>（2）下载head插件</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# wget https://github.com/mobz/elasticsearch-head/archive/master.zip</span><br><span class="line">[root@es-3-head-kib ~]# cp master.zip /usr/local/</span><br><span class="line">[root@es-3-head-kib ~]# yum -y install unzip</span><br><span class="line">[root@es-3-head-kib ~]# cd /usr/local</span><br><span class="line">[root@es-3-head-kib ~]# unzip  master.zip</span><br></pre></td></tr></table></figure>

<h6 id="（3）安装grunt"><a href="#（3）安装grunt" class="headerlink" title="（3）安装grunt"></a>（3）安装grunt</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# cd elasticsearch-head-master/</span><br><span class="line">[root@mes-3-head-kib elasticsearch-head-master]# npm install -g grunt-cli  #时间会很长</span><br><span class="line">[root@es-3-head-kib elasticsearch-head-master]# grunt --version  #检查grunt版本号</span><br><span class="line">grunt-cli v1.3.2</span><br></pre></td></tr></table></figure>

<h6 id="（4）修改head源码"><a href="#（4）修改head源码" class="headerlink" title="（4）修改head源码"></a>（4）修改head源码</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib elasticsearch-head-master]# vim /usr/local/elasticsearch-head-master/Gruntfile.js   （95左右）</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/e24ea60255735e9c7800ae60a108c247.png" alt="ELK6.5+Beats6.5+Kafka2.1.0集群搭建"><br>添加hostname，注意在上一行末尾添加逗号,hostname 不需要添加逗号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib elasticsearch-head-master]# vim /usr/local/elasticsearch-head-master/_site/app.js     (4359左右)</span><br></pre></td></tr></table></figure>

<p>如果在一台机器上面可以不修改下面的操作。保持原来的就可以了</p>
<p>如果是集群需要修改如下信息:</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564835514688.png" alt="1564835514688"><br>原本是<a href="http://localhost:9200/">http://localhost:9200</a> ，如果head和ES不在同一个节点，注意修改成ES的IP地址</p>
<h6 id="（5）下载head必要的文件"><a href="#（5）下载head必要的文件" class="headerlink" title="（5）下载head必要的文件"></a>（5）下载head必要的文件</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# wget https://github.com/Medium/phantomjs/releases/download/v2.1.1/phantomjs-2.1.1-linux-x86_64.tar.bz2</span><br><span class="line">[root@es-3-head-kib ~]# yum -y install bzip2</span><br><span class="line">[root@es-3-head-kib ~]# tar -jxf phantomjs-2.1.1-linux-x86_64.tar.bz2 -C /tmp/  #解压</span><br></pre></td></tr></table></figure>

<h6 id="（6）运行head"><a href="#（6）运行head" class="headerlink" title="（6）运行head"></a>（6）运行head</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# cd /usr/local/elasticsearch-head-master/</span><br><span class="line">[root@es-3-head-kib ~]# npm config set registry https://registry.npm.taobao.org</span><br><span class="line">[root@es-3-head-kib elasticsearch-head-master]# npm install</span><br><span class="line">...</span><br><span class="line">grunt-contrib-jasmine@1.0.3 node_modules/grunt-contrib-jasmine</span><br><span class="line">├── sprintf-js@1.0.3</span><br><span class="line">├── lodash@2.4.2</span><br><span class="line">├── es5-shim@4.5.13</span><br><span class="line">├── chalk@1.1.3 (escape-string-regexp@1.0.5, supports-color@2.0.0, ansi-styles@2.2.1, strip-ansi@3.0.1, has-ansi@2.0.0)</span><br><span class="line">├── jasmine-core@2.99.1</span><br><span class="line">├── rimraf@2.6.3 (glob@7.1.4)</span><br><span class="line">└── grunt-lib-phantomjs@1.1.0 (eventemitter2@0.4.14, semver@5.7.0, temporary@0.0.8, phan</span><br><span class="line">[root@es-3-head-kib elasticsearch-head-master]# nohup grunt server &amp;</span><br><span class="line">[root@es-3-head-kib elasticsearch-head-master]# tail -f nohup.out </span><br><span class="line">Running &quot;connect:server&quot; (connect) task</span><br><span class="line">Waiting forever...</span><br><span class="line">Started connect web server on http://localhost:9100</span><br></pre></td></tr></table></figure>

<h6 id="（7）测试"><a href="#（7）测试" class="headerlink" title="（7）测试"></a>（7）测试</h6><p>访问<br><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564843494631.png" alt="1564843494631"></p>
<h4 id="2、-Kibana部署"><a href="#2、-Kibana部署" class="headerlink" title="2、 Kibana部署"></a>2、 Kibana部署</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">系统类型：Centos7.5</span><br><span class="line">节点IP：192.168.246.235 D</span><br><span class="line">软件版本：nginx-1.14.2、kibana-6.5.4-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="1-安装配置Kibana"><a href="#1-安装配置Kibana" class="headerlink" title="1. 安装配置Kibana"></a>1. 安装配置Kibana</h5><h6 id="（1）安装"><a href="#（1）安装" class="headerlink" title="（1）安装"></a>（1）安装</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# tar zvxf kibana-6.5.4-linux-x86_64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>

<h6 id="（2）配置"><a href="#（2）配置" class="headerlink" title="（2）配置"></a>（2）配置</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# cd /usr/local/kibana-6.5.4-linux-x86_64/config/</span><br><span class="line">[root@es-3-head-kib config]# vim kibana.yml</span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;192.168.246.235&quot;     #kibana本机的地址</span><br><span class="line">elasticsearch.url: &quot;http://192.168.246.234:9200&quot;    #ES主节点地址+端口</span><br><span class="line">kibana.index: &quot;.kibana&quot;</span><br></pre></td></tr></table></figure>

<p>配置项含义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server.port kibana 服务端口，默认5601</span><br><span class="line">server.host kibana 主机IP地址，默认localhost</span><br><span class="line">elasticsearch.url  用来做查询的ES节点的URL，默认http://localhost:9200</span><br><span class="line">kibana.index       kibana在Elasticsearch中使用索引来存储保存的searches, visualizations和dashboards，默认.kibana</span><br></pre></td></tr></table></figure>

<p>其他配置项可参考：<br><a href="https://www.elastic.co/guide/en/kibana/6.5/settings.html">https://www.elastic.co/guide/en/kibana/6.5/settings.html</a></p>
<h6 id="（3）启动"><a href="#（3）启动" class="headerlink" title="（3）启动"></a>（3）启动</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib config]# cd ..</span><br><span class="line">[root@es-3-head-kib kibana-6.5.4-linux-x86_64]# nohup ./bin/kibana &amp; </span><br><span class="line">[1] 12054</span><br><span class="line">[root@es-3-head-kib kibana-6.5.4-linux-x86_64]# nohup: ignoring input and appending output to ‘nohup.out’</span><br></pre></td></tr></table></figure>

<h5 id="2-安装配置Nginx反向代理"><a href="#2-安装配置Nginx反向代理" class="headerlink" title="2. 安装配置Nginx反向代理"></a>2. 安装配置Nginx反向代理</h5><h6 id="（1）配置YUM源："><a href="#（1）配置YUM源：" class="headerlink" title="（1）配置YUM源："></a>（1）配置YUM源：</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure>

<h6 id="（2）安装："><a href="#（2）安装：" class="headerlink" title="（2）安装："></a>（2）安装：</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# yum install -y nginx </span><br></pre></td></tr></table></figure>



<h6 id="（3）配置反向代理"><a href="#（3）配置反向代理" class="headerlink" title="（3）配置反向代理"></a>（3）配置反向代理</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# cd /etc/nginx/conf.d/</span><br><span class="line">[root@es-3-head-kib conf.d]# cp default.conf nginx.conf</span><br><span class="line">[root@es-3-head-kib conf.d]# mv default.conf default.conf.bak</span><br><span class="line">[root@es-3-head-kib conf.d]# vim nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.246.235;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       # access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log  main;</span><br><span class="line">       # access_log off;</span><br><span class="line"></span><br><span class="line">         location &#x2F; &#123;  </span><br><span class="line">             proxy_pass http:&#x2F;&#x2F;192.168.246.235:5601;</span><br><span class="line">             proxy_set_header Host $host:5601;  </span><br><span class="line">             proxy_set_header X-Real-IP $remote_addr;  </span><br><span class="line">             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class="line">             proxy_set_header Via &quot;nginx&quot;;</span><br><span class="line">                     &#125;</span><br><span class="line">         location &#x2F;status &#123; </span><br><span class="line">             stub_status on; #开启网站监控状态 </span><br><span class="line">             access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;kibana_status.log; #监控日志 </span><br><span class="line">             auth_basic &quot;NginxStatus&quot;; &#125;</span><br><span class="line"></span><br><span class="line">         location &#x2F;head&#x2F;&#123;</span><br><span class="line">             proxy_pass http:&#x2F;&#x2F;192.168.246.235:9100;</span><br><span class="line">             proxy_set_header Host $host:9100;</span><br><span class="line">             proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             proxy_set_header Via &quot;nginx&quot;;</span><br><span class="line">                         &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）配置nginx</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.将原来的log_format注释掉，添加json格式的配置信息，如下：</span><br><span class="line">[root@es-3-head-kib conf.d]# vim /etc/nginx/nginx.conf</span><br><span class="line">log_format  json &#x27;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;@version&quot;:&quot;1&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;client&quot;:&quot;$remote_addr&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;url&quot;:&quot;$uri&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;status&quot;:&quot;$status&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;domain&quot;:&quot;$host&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;host&quot;:&quot;$server_addr&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;size&quot;:$body_bytes_sent,&#x27;</span><br><span class="line">                           &#x27;&quot;responsetime&quot;:$request_time,&#x27;</span><br><span class="line">                           &#x27;&quot;referer&quot;: &quot;$http_referer&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;ua&quot;: &quot;$http_user_agent&quot;&#x27;</span><br><span class="line">               &#x27;&#125;&#x27;;</span><br><span class="line">2.引用定义的json格式的日志：</span><br><span class="line">access_log  /var/log/nginx/access_json.log  json;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1570152204833.png" alt="1570152204833"></p>
<h6 id="（5）启动nginx"><a href="#（5）启动nginx" class="headerlink" title="（5）启动nginx"></a>（5）启动nginx</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@es-3-head-kib ~]# systemctl start nginx</span><br></pre></td></tr></table></figure>

<p>浏览器访问<a href="http://192.168.246.235/">http://192.168.246.235</a> 刚开始没有任何数据，会提示你创建新的索引。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564845826766.png" alt="1564845826766"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/edff24ad252165487b6841ac2d7ac959.png" alt="ELK6.5+Beats6.5+Kafka2.1.0集群搭建"></p>
<h4 id="3、-Logstash部署—-192-168-246-231"><a href="#3、-Logstash部署—-192-168-246-231" class="headerlink" title="3、 Logstash部署—-192.168.246.231"></a>3、 Logstash部署—-192.168.246.231</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">系统类型：Centos7.5</span><br><span class="line">节点IP：192.168.246.231   E</span><br><span class="line">软件版本：jdk-8u121-linux-x64.tar.gz、logstash-6.5.4.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="1-安装配置Logstash"><a href="#1-安装配置Logstash" class="headerlink" title="1.安装配置Logstash"></a>1.安装配置Logstash</h5><p>Logstash运行同样依赖jdk，本次为节省资源，故将Logstash安装在了kafka244.231节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log ~]# tar -xvzf jdk-8u211-linux-x64.tar.gz  -C /usr/local/</span><br><span class="line">[root@es-2-zk-log ~]# cd /usr/local/</span><br><span class="line">[root@es-2-zk-log ~]# mv jdk1.8.0_211/ java</span><br><span class="line">[root@es-2-zk-log ~]# vim /etc/profile</span><br><span class="line">[root@es-2-zk-log elk_packages]# tail -3 /etc/profile</span><br><span class="line">JAVA_HOME=/usr/local/java</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure>

<h6 id="（1）安装-1"><a href="#（1）安装-1" class="headerlink" title="（1）安装"></a>（1）安装</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log ~]# tar xvzf logstash-6.5.4.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>

<h6 id="（2）配置-1"><a href="#（2）配置-1" class="headerlink" title="（2）配置"></a>（2）配置</h6><p>创建目录，我们将所有input、filter、output配置文件全部放到该目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.安装nginx:</span><br><span class="line">[root@es-2-zk-log ~]# rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line">[root@es-2-zk-log ~]# yum install -y nginx</span><br><span class="line">将原来的日志格式注释掉定义成json格式：</span><br><span class="line">[root@es-2-zk-log conf.d]# vim /etc/nginx/nginx.conf</span><br><span class="line">log_format  json &#x27;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;@version&quot;:&quot;1&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;client&quot;:&quot;$remote_addr&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;url&quot;:&quot;$uri&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;status&quot;:&quot;$status&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;domain&quot;:&quot;$host&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;host&quot;:&quot;$server_addr&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;size&quot;:$body_bytes_sent,&#x27;</span><br><span class="line">                           &#x27;&quot;responsetime&quot;:$request_time,&#x27;</span><br><span class="line">                           &#x27;&quot;referer&quot;: &quot;$http_referer&quot;,&#x27;</span><br><span class="line">                           &#x27;&quot;ua&quot;: &quot;$http_user_agent&quot;&#x27;</span><br><span class="line">               &#x27;&#125;&#x27;;</span><br><span class="line">2.引用定义的json格式的日志：</span><br><span class="line">access_log  /var/log/nginx/access_json.log  json;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1570152204833.png" alt="1570152204833"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log ~]# systemctl start nginx </span><br><span class="line">[root@es-2-zk-log ~]# systemctl enable nginx</span><br><span class="line">浏览器多访问几次</span><br><span class="line">[root@es-2-zk-log ~]# mkdir -p /usr/local/logstash-6.5.4/etc/conf.d</span><br><span class="line">[root@es-2-zk-log ~]# cd /usr/local/logstash-6.5.4/etc/conf.d/       </span><br><span class="line">[root@es-2-zk-log conf.d]# vim input.conf       #---在下面添加</span><br><span class="line">input&#123;                        #让logstash可以读取特定的事件源。</span><br><span class="line"></span><br><span class="line">    file&#123;                                       #从文件读取</span><br><span class="line"></span><br><span class="line">   path =&gt; [&quot;/var/log/nginx/access_json.log&quot;]        #要输入的文件路径</span><br><span class="line"><span class="meta">#</span><span class="bash">   code =&gt; <span class="string">&quot;json&quot;</span>               <span class="comment">#定义编码，用什么格式输入和输出，由于日志就是json格式，这里不用再写</span></span></span><br><span class="line"></span><br><span class="line">        type =&gt; &quot;shopweb&quot;                       #定义一个类型，通用选项. 用于激活过滤器</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@es-2-zk-log conf.d]# vim output.conf</span><br><span class="line">output&#123;           #输出插件，将事件发送到特定目标</span><br><span class="line">    elasticsearch &#123;            #输出到es</span><br><span class="line">    hosts =&gt; [&quot;192.168.246.234:9200&quot;]       #指定es服务的ip加端口</span><br><span class="line">    index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]     #引用input中的type名称，定义输出的格式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">启动：</span><br><span class="line">[root@es-2-zk-log conf.d]# cd /usr/local/logstash-6.5.4/</span><br><span class="line">[root@es-2-zk-log logstash-6.5.4]# nohup bin/logstash -f etc/conf.d/  --config.reload.automatic &amp;</span><br></pre></td></tr></table></figure>

<p>查看日志出现:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log logstash-6.5.4]# tail -f nohup.out</span><br><span class="line">[2019-08-04T01:39:24,671][INFO ][logstash.outputs.elasticsearch] Attempting to install template &#123;:manage_template=&gt;&#123;&quot;template&quot;=&gt;&quot;logstash-*&quot;, &quot;version&quot;=&gt;60001, &quot;settings&quot;=&gt;&#123;&quot;index.refresh_interval&quot;=&gt;&quot;5s&quot;&#125;, &quot;mappings&quot;=&gt;&#123;&quot;_default_&quot;=&gt;&#123;&quot;dynamic_templates&quot;=&gt;[&#123;&quot;message_field&quot;=&gt;&#123;&quot;path_match&quot;=&gt;&quot;message&quot;, &quot;match_mapping_type&quot;=&gt;&quot;string&quot;, &quot;mapping&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;text&quot;, &quot;norms&quot;=&gt;false&#125;&#125;&#125;, &#123;&quot;string_fields&quot;=&gt;&#123;&quot;match&quot;=&gt;&quot;*&quot;, &quot;match_mapping_type&quot;=&gt;&quot;string&quot;, &quot;mapping&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;text&quot;, &quot;norms&quot;=&gt;false, &quot;fields&quot;=&gt;&#123;&quot;keyword&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;keyword&quot;, &quot;ignore_above&quot;=&gt;256&#125;&#125;&#125;&#125;&#125;], &quot;properties&quot;=&gt;&#123;&quot;@timestamp&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;date&quot;&#125;, &quot;@version&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;keyword&quot;&#125;, &quot;geoip&quot;=&gt;&#123;&quot;dynamic&quot;=&gt;true, &quot;properties&quot;=&gt;&#123;&quot;ip&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;ip&quot;&#125;, &quot;location&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;geo_point&quot;&#125;, &quot;latitude&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;half_float&quot;&#125;, &quot;longitude&quot;=&gt;&#123;&quot;type&quot;=&gt;&quot;half_float&quot;&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问本机的nginx网站</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1585455873226.png" alt="1585455873226"></p>
<p>然后去head插件页面查看是否有shopweb索引出现</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564854540194.png" alt="1564854540194"></p>
<p>发现之后，去配置kibanna添加索引</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1570984081341.png" alt="1570984081341"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564855064677.png" alt="1564855064677"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564855109762.png" alt="1564855109762"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564855159101.png" alt="1564855159101"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564855751946.png" alt="1564855751946"></p>
<p>可以根据某个特定的值，来查看记录，比如</p>
<p>多刷新几次本机的nginx页面，可以看到相应的日志记录</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1585456157823.png" alt="1585456157823"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1585456186751.png" alt="1585456186751"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1585456340864.png" alt="1585456340864"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1585456285840.png" alt="1585456285840"></p>
<p>作业,收集Tomcat日志，配置文件已提供：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log logstash-6.5.4]# cat etc/conf.d/tomcat.conf </span><br><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">      path =&gt; &quot;/apps/tomcat/logs/localhost_access_log*.txt&quot;</span><br><span class="line">      type =&gt; &quot;tomcat&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">      start_position =&gt; <span class="string">&quot;beginning&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">      stat_interval =&gt; <span class="string">&quot;2&quot;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">      hosts =&gt; [&quot;192.168.1.121:9200&quot;]</span><br><span class="line">      index =&gt; [&quot;%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做出来应该是以下效果：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1585461510791.png" alt="1585461510791"></p>
<p><strong>注意:如果进程关闭,页面将会访问失败，需要重启head,kibana,logstash</strong></p>
<p>注意:如果出不来通过界面提示打开时间管理器，设置时间为本星期**</p>
<p>过程: 通过nginx的访问日志获取日志—&gt;传输到logstach —-传输到–elasticsearch–传输到—kibana （通过nginix反代）</p>
<p>注意：如果出现问题</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1570153469829.png" alt="1570153469829"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">从上面截图可以看出存在5个unassigned的分片，新建索引blog5的时候，分片数为5，副本数为1，新建之后集群状态成为yellow，其根本原因是因为集群存在没有启用的副本分片，我们先来看一下官网给出的副本分片的介绍：</span><br><span class="line">副本分片的主要目的就是为了故障转移，正如在 集群内的原理 中讨论的：如果持有主分片的节点挂掉了，一个副本分片就会晋升为主分片的角色。</span><br><span class="line"></span><br><span class="line">那么可以看出来副本分片和主分片是不能放到一个节点上面的，可是在只有一个节点的集群里，副本分片没有办法分配到其他的节点上，所以出现所有副本分片都unassigned得情况。因为只有一个节点，如果存在主分片节点挂掉了，那么整个集群理应就挂掉了，不存在副本分片升为主分片的情况。</span><br><span class="line"></span><br><span class="line">解决办法就是，在单节点的elasticsearch集群，删除存在副本分片的索引，新建索引的副本都设为0。然后再查看集群状态 </span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1570153562703.png" alt="1570153562703"></p>
<h4 id="4、-Kafka部署"><a href="#4、-Kafka部署" class="headerlink" title="4、 Kafka部署"></a>4、 Kafka部署</h4><h4 id="4、Kafka："><a href="#4、Kafka：" class="headerlink" title="4、Kafka："></a>4、Kafka：</h4><p>​    数据缓冲队列。同时提高了可扩展性。具有峰值处理能力，使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。<strong>是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、web/nginx日志、访问日志，消息服务等等</strong>，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>
<p><strong>Kafka的特性:</strong></p>
<ul>
<li><p>高吞吐量：kafka每秒可以处理几十万条消息。</p>
</li>
<li><p>可扩展性：kafka集群支持热扩展- 持久性、</p>
</li>
<li><p>可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p>
</li>
<li><p>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p>
</li>
<li><p>高并发：支持数千个客户端同时读写</p>
<p>它主要包括以下组件  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">话题（Topic）：是特定类型的消息流。(每条发布到 kafka 集群的消息属于的类别，即 kafka 是面向 topic 的)</span><br><span class="line">生产者（Producer）：是能够发布消息到话题的任何对象(发布消息到 kafka 集群的终端或服务).</span><br><span class="line">消费者（Consumer）：可以订阅一个或多个话题，从而消费这些已发布的消息。</span><br><span class="line">服务代理（Broker）：已发布的消息保存在一组服务器中，它们被称为代理（Broker）或Kafka集群。</span><br><span class="line">partition（区）：每个 topic 包含一个或多个 partition。</span><br><span class="line">replication：partition 的副本，保障 partition 的高可用。</span><br><span class="line">leader：replica 中的一个角色， producer 和 consumer 只跟 leader 交互。</span><br><span class="line">follower：replica 中的一个角色，从 leader 中复制数据。</span><br><span class="line">zookeeper：kafka 通过 zookeeper 来存储集群的 信息。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper:"></a><strong>zookeeper:</strong></h4><p>  <strong>ZooKeeper是一个分布式协调服务，它的主要作用是为分布式系统提供一致性服务，提供的功能包括：配置维护、分布式同步等。Kafka的运行依赖ZooKeeper。</strong></p>
<p>  ZooKeeper用于分布式系统的协调，Kafka使用ZooKeeper也是基于相同的原因。ZooKeeper主要用来协调Kafka的各个broker，不仅可以实现broker的负载均衡，而且当增加了broker或者某个broker故障了，ZooKeeper将会通知生产者和消费者，这样可以保证整个系统正常运转。</p>
<p>  在Kafka中,一个topic会被分成多个区并被分到多个broker上，分区的信息以及broker的分布情况与消费者当前消费的状态信息都会保存在ZooKeeper中。</p>
<p><strong>搭建架构</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1570166424599.png" alt="1570166424599"></p>
<p><strong>filebeat安装在要收集日志的应用服务器中，filebeat收集到日志之后传输到kafka中，logstash通过kafka拿到日志，在由logstash传给后面的es，es将日志传给后面的kibana，最后通过kibana展示出来。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统类型：Centos7.5</span><br><span class="line">节点IP：192.168.246.234,192.168.246.231、192.168.246.235</span><br><span class="line">软件版本：jdk-8u121-linux-x64.tar.gz、kafka_2.11-2.1.0.tgz</span><br><span class="line">示例节点：172.16.246.231</span><br></pre></td></tr></table></figure>

<h5 id="1-安装配置jdk8"><a href="#1-安装配置jdk8" class="headerlink" title="1.安装配置jdk8"></a>1.安装配置jdk8</h5><h6 id="（1）Kafka、Zookeeper（简称：ZK）运行依赖jdk8"><a href="#（1）Kafka、Zookeeper（简称：ZK）运行依赖jdk8" class="headerlink" title="（1）Kafka、Zookeeper（简称：ZK）运行依赖jdk8"></a>（1）Kafka、Zookeeper（简称：ZK）运行依赖jdk8</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf /usr/local/package/jdk-8u121-linux-x64.tar.gz -C /usr/local/</span><br><span class="line">echo &#x27;</span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_121</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export JAVA_HOME PATH</span><br><span class="line">&#x27; &gt;&gt;/etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<h5 id="2-安装配置ZK"><a href="#2-安装配置ZK" class="headerlink" title="2.安装配置ZK"></a>2.安装配置ZK</h5><p>Kafka运行依赖ZK，Kafka官网提供的tar包中，已经包含了ZK，这里不再额下载ZK程序。</p>
<p>配置相互解析—三台机器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log ~]# vim /etc/hosts</span><br><span class="line">192.168.246.234 mes-1</span><br><span class="line">192.168.246.231 es-2-zk-log</span><br><span class="line">192.168.246.235 es-3-head-kib</span><br></pre></td></tr></table></figure>

<h6 id="（1）安装-2"><a href="#（1）安装-2" class="headerlink" title="（1）安装"></a>（1）安装</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log ~]# tar xzvf kafka_2.11-2.1.0.tgz -C /usr/local/</span><br></pre></td></tr></table></figure>

<h6 id="（2）配置-2"><a href="#（2）配置-2" class="headerlink" title="（2）配置"></a>（2）配置</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# sed -i &#x27;s/^[^#]/#&amp;/&#x27; /usr/local/kafka_2.11-2.1.0/config/zookeeper.properties</span><br><span class="line">[root@mes-1 ~]# vim /usr/local/kafka_2.11-2.1.0/config/zookeeper.properties  #添加如下配置</span><br><span class="line">dataDir=/opt/data/zookeeper/data </span><br><span class="line">dataLogDir=/opt/data/zookeeper/logs</span><br><span class="line">clientPort=2181 </span><br><span class="line">tickTime=2000 </span><br><span class="line">initLimit=20 </span><br><span class="line">syncLimit=10 </span><br><span class="line">server.1=192.168.246.231:2888:3888             //kafka集群IP:Port</span><br><span class="line">server.2=192.168.246.234:2888:3888</span><br><span class="line">server.3=192.168.246.235:2888:3888</span><br><span class="line"><span class="meta">#</span><span class="bash">创建data、<span class="built_in">log</span>目录</span></span><br><span class="line">[root@mes-1 ~]# mkdir -p /opt/data/zookeeper/&#123;data,logs&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建myid文件</span></span><br><span class="line">[root@mes-1 ~]# echo 1 &gt; /opt/data/zookeeper/data/myid     #myid号按顺序排</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log ~]# sed -i &#x27;s/^[^#]/#&amp;/&#x27; /usr/local/kafka_2.11-2.1.0/config/zookeeper.properties</span><br><span class="line">[root@es-2-zk-log ~]# vim /usr/local/kafka_2.11-2.1.0/config/zookeeper.properties</span><br><span class="line">dataDir=/opt/data/zookeeper/data </span><br><span class="line">dataLogDir=/opt/data/zookeeper/logs</span><br><span class="line">clientPort=2181 </span><br><span class="line">tickTime=2000 </span><br><span class="line">initLimit=20 </span><br><span class="line">syncLimit=10 </span><br><span class="line">server.1=192.168.246.231:2888:3888</span><br><span class="line">server.2=192.168.246.234:2888:3888</span><br><span class="line">server.3=192.168.246.235:2888:3888</span><br><span class="line"><span class="meta">#</span><span class="bash">创建data、<span class="built_in">log</span>目录</span></span><br><span class="line">[root@es-2-zk-log ~]# mkdir -p /opt/data/zookeeper/&#123;data,logs&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建myid文件</span></span><br><span class="line">[root@es-2-zk-log ~]# echo 2 &gt; /opt/data/zookeeper/data/myid</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3 ~]# sed -i &#x27;s/^[^#]/#&amp;/&#x27; /usr/local/kafka_2.11-2.1.0/config/zookeeper.properties</span><br><span class="line">[root@es-3-head-kib ~]# vim /usr/local/kafka_2.11-2.1.0/config/zookeeper.properties</span><br><span class="line">dataDir=/opt/data/zookeeper/data </span><br><span class="line">dataLogDir=/opt/data/zookeeper/logs</span><br><span class="line">clientPort=2181 </span><br><span class="line">tickTime=2000 </span><br><span class="line">initLimit=20 </span><br><span class="line">syncLimit=10 </span><br><span class="line">server.1=192.168.246.231:2888:3888</span><br><span class="line">server.2=192.168.246.234:2888:3888</span><br><span class="line">server.3=192.168.246.235:2888:3888</span><br><span class="line"><span class="meta">#</span><span class="bash">创建data、<span class="built_in">log</span>目录</span></span><br><span class="line">[root@es-3-head-kib ~]# mkdir -p /opt/data/zookeeper/&#123;data,logs&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">创建myid文件</span></span><br><span class="line">[root@es-3-head-kib ~]# echo 3 &gt; /opt/data/zookeeper/data/myid</span><br></pre></td></tr></table></figure>

<p>配置项含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir ZK数据存放目录。</span><br><span class="line">dataLogDir  ZK日志存放目录。</span><br><span class="line">clientPort  客户端连接ZK服务的端口。</span><br><span class="line">tickTime        ZK服务器之间或客户端与服务器之间维持心跳的时间间隔。</span><br><span class="line">initLimit       允许follower连接并同步到Leader的初始化连接时间，当初始化连接时间超过该值，则表示连接失败。</span><br><span class="line">syncLimit   Leader与Follower之间发送消息时如果follower在设置时间内不能与leader通信，那么此follower将会被丢弃。</span><br><span class="line">server.1&#x3D;172.16.244.31:2888:3888    2888是follower与leader交换信息的端口，3888是当leader挂了时用来执行选举时服务器相互通信的端口。</span><br></pre></td></tr></table></figure>

<h5 id="3-配置Kafka"><a href="#3-配置Kafka" class="headerlink" title="3.配置Kafka"></a>3.配置Kafka</h5><h6 id="（1）配置"><a href="#（1）配置" class="headerlink" title="（1）配置"></a>（1）配置</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# sed -i &#x27;s/^[^#]/#&amp;/&#x27; /usr/local/kafka_2.11-2.1.0/config/server.properties</span><br><span class="line">[root@mes-1 ~]# vim /usr/local/kafka_2.11-2.1.0/config/server.properties  #在最后添加</span><br><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://192.168.246.231:9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/opt/data/kafka/logs</span><br><span class="line">num.partitions=6</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=2</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=536870912</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=192.168.246.231:2181,192.168.246.234:2181,192.168.246.235:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br><span class="line">[root@mes-1 ~]# mkdir -p /opt/data/kafka/logs</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log ~]# sed -i &#x27;s/^[^#]/#&amp;/&#x27; /usr/local/kafka_2.11-2.1.0/config/server.properties</span><br><span class="line">[root@es-2-zk-log ~]# vim /usr/local/kafka_2.11-2.1.0/config/server.properties</span><br><span class="line">broker.id=2</span><br><span class="line">listeners=PLAINTEXT://192.168.246.234:9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/opt/data/kafka/logs</span><br><span class="line">num.partitions=6</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=2</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=536870912</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=192.168.246.231:2181,192.168.246.234:2181,192.168.246.235:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br><span class="line">[root@es-2-zk-log ~]# mkdir -p /opt/data/kafka/logs</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# sed -i &#x27;s/^[^#]/#&amp;/&#x27; /usr/local/kafka_2.11-2.1.0/config/server.properties</span><br><span class="line">[root@es-3-head-kib ~]# vim /usr/local/kafka_2.11-2.1.0/config/server.properties</span><br><span class="line">broker.id=3</span><br><span class="line">listeners=PLAINTEXT://192.168.246.235:9092</span><br><span class="line">num.network.threads=3</span><br><span class="line">num.io.threads=8</span><br><span class="line">socket.send.buffer.bytes=102400</span><br><span class="line">socket.receive.buffer.bytes=102400</span><br><span class="line">socket.request.max.bytes=104857600</span><br><span class="line">log.dirs=/opt/data/kafka/logs</span><br><span class="line">num.partitions=6</span><br><span class="line">num.recovery.threads.per.data.dir=1</span><br><span class="line">offsets.topic.replication.factor=2</span><br><span class="line">transaction.state.log.replication.factor=1</span><br><span class="line">transaction.state.log.min.isr=1</span><br><span class="line">log.retention.hours=168</span><br><span class="line">log.segment.bytes=536870912</span><br><span class="line">log.retention.check.interval.ms=300000</span><br><span class="line">zookeeper.connect=192.168.246.231:2181,192.168.246.234:2181,192.168.246.235:2181</span><br><span class="line">zookeeper.connection.timeout.ms=6000</span><br><span class="line">group.initial.rebalance.delay.ms=0</span><br><span class="line">[root@es-3-head-kib ~]# mkdir -p /opt/data/kafka/logs</span><br></pre></td></tr></table></figure>

<p>配置项含义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#每个server需要单独配置broker id，如果不配置系统会自动配置。</span><br><span class="line">broker.id  </span><br><span class="line"></span><br><span class="line">#监听地址，格式PLAINTEXT:&#x2F;&#x2F;IP:端口。</span><br><span class="line">listeners  </span><br><span class="line"></span><br><span class="line">#处理网络请求的线程数量，也就是接收消息的线程数。</span><br><span class="line">num.network.threads    </span><br><span class="line"></span><br><span class="line">#消息从内存中写入磁盘是时候使用的线程数量。</span><br><span class="line">num.io.threads    </span><br><span class="line"></span><br><span class="line">#发送套接字的缓冲区大小</span><br><span class="line">socket.send.buffer.bytes </span><br><span class="line"></span><br><span class="line">#当消息的尺寸不足时,server阻塞的时间,如果超时,</span><br><span class="line">#消息将立即发送给consumer</span><br><span class="line">socket.receive.buffer.bytes    </span><br><span class="line"></span><br><span class="line">服务器将接受的请求的最大大小(防止OOM)</span><br><span class="line">socket.request.max.bytes  </span><br><span class="line"></span><br><span class="line">日志文件目录。</span><br><span class="line">log.dirs    </span><br><span class="line"></span><br><span class="line">#topic在当前broker上的分片个数</span><br><span class="line">num.partitions</span><br><span class="line"></span><br><span class="line">#用来设置恢复和清理data下数据的线程数量</span><br><span class="line">num.recovery.threads.per.data.dir </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offsets.topic.replication.factor</span><br><span class="line"></span><br><span class="line">#超时将被删除</span><br><span class="line">log.retention.hours</span><br><span class="line"></span><br><span class="line">#日志文件中每个segment的大小，默认为1G</span><br><span class="line">log.segment.bytes</span><br><span class="line"></span><br><span class="line">#上面的参数设置了每一个segment文件的大小是1G，那么</span><br><span class="line">#就需要有一个东西去定期检查segment文件有没有达到1G，</span><br><span class="line">#多长时间去检查一次，就需要设置一个周期性检查文件大小</span><br><span class="line">#的时间（单位是毫秒）</span><br><span class="line">log.retention.check.interval.ms </span><br><span class="line"></span><br><span class="line">#ZK主机地址，如果zookeeper是集群则以逗号隔开</span><br><span class="line">zookeeper.connect  </span><br><span class="line"></span><br><span class="line">#连接到Zookeeper的超时时间。</span><br><span class="line">zookeeper.connection.timeout.ms     </span><br></pre></td></tr></table></figure>

<h5 id="4、其他节点配置"><a href="#4、其他节点配置" class="headerlink" title="4、其他节点配置"></a>4、其他节点配置</h5><p>只需把配置好的安装包直接分发到其他节点，Kafka的broker.id和listeners就可以了。</p>
<h5 id="5、启动、验证ZK集群"><a href="#5、启动、验证ZK集群" class="headerlink" title="5、启动、验证ZK集群"></a>5、启动、验证ZK集群</h5><h6 id="（1）启动"><a href="#（1）启动" class="headerlink" title="（1）启动"></a>（1）启动</h6><p>在三个节点依次执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# cd /usr/local/kafka_2.11-2.1.0/</span><br><span class="line">[root@mes-1 kafka_2.11-2.1.0]# nohup bin/zookeeper-server-start.sh config/zookeeper.properties &amp;</span><br></pre></td></tr></table></figure>

<h6 id="（2）验证"><a href="#（2）验证" class="headerlink" title="（2）验证"></a>（2）验证</h6><p>查看端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# netstat -lntp | grep 2181</span><br><span class="line">tcp6       0      0 :::2181                 :::*                    LISTEN      1226/java</span><br></pre></td></tr></table></figure>

<h5 id="6、启动、验证Kafka"><a href="#6、启动、验证Kafka" class="headerlink" title="6、启动、验证Kafka"></a>6、启动、验证Kafka</h5><h6 id="（1）启动-1"><a href="#（1）启动-1" class="headerlink" title="（1）启动"></a>（1）启动</h6><p>在三个节点依次执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@mes-1 ~]# cd /usr/local/kafka_2.11-2.1.0/</span><br><span class="line">[root@mes-1 kafka_2.11-2.1.0]# nohup bin/kafka-server-start.sh config/server.properties &amp;</span><br></pre></td></tr></table></figure>

<h6 id="（2）验证-1"><a href="#（2）验证-1" class="headerlink" title="（2）验证"></a>（2）验证</h6><p>在192.168.246.231上创建topic</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log kafka_2.11-2.1.0]# bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic testtopic</span><br><span class="line">Created topic &quot;testtopic&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在246.235上面查询192.168.246.231上的topic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib kafka_2.11-2.1.0]# bin&#x2F;kafka-topics.sh --zookeeper 192.168.246.231:2181 --list</span><br><span class="line">testtopic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模拟消息生产和消费<br>发送消息到192.168.246.231</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@mes-1 kafka_2.11-2.1.0]# bin&#x2F;kafka-console-producer.sh --broker-list 192.168.246.231:9092 --topic testtopic</span><br><span class="line">&gt;hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从192.168.246.234接受消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@es-2-zk-log kafka_2.11-2.1.0]# bin&#x2F;kafka-console-consumer.sh --bootstrap-server  192.168.246.234:9092 --topic testtopic --from-beginning</span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka没有问题之后，回到logstash服务器：</span><br><span class="line"><span class="meta">#</span><span class="bash">安装完kafka之后的操作：</span></span><br><span class="line">[root@es-2-zk-log ~]# cd /usr/local/logstash-6.5.4/etc/conf.d/</span><br><span class="line">[root@es-2-zk-log conf.d]# cp input.conf input.conf.bak</span><br><span class="line">[root@es-2-zk-log conf.d]# vim input.conf</span><br><span class="line">input &#123;</span><br><span class="line">kafka &#123;               #指定kafka服务</span><br><span class="line">    type =&gt; &quot;nginx_log&quot;</span><br><span class="line">    codec =&gt; &quot;json&quot;        #通用选项，用于输入数据的编解码器</span><br><span class="line">    topics =&gt; &quot;nginx&quot;        #这里定义的topic</span><br><span class="line">    decorate_events =&gt; true  #此属性会将当前topic、group、partition等信息也带到message中</span><br><span class="line">    bootstrap_servers =&gt; &quot;192.168.246.234:9092, 192.168.246.231:9092, 192.168.246.235:9092&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">启动 logstash</span><br><span class="line">[root@es-2-zk-log conf.d]# cd /usr/local/logstash-6.5.4/</span><br><span class="line">[root@es-2-zk-log logstash-6.5.4]# nohup bin/logstash -f etc/conf.d/  --config.reload.automatic &amp;</span><br></pre></td></tr></table></figure>

<h4 id="5、Filebeat"><a href="#5、Filebeat" class="headerlink" title="5、Filebeat"></a>5、Filebeat</h4><p>​    隶属于Beats,轻量级数据收集引擎。基于原先 Logstash-fowarder 的源码改造出来。换句话说：Filebeat就是新版的 Logstash-fowarder，也会是 ELK Stack 在 Agent 的第一选择,目前Beats包含四种工具：</p>
<ul>
<li>1.Packetbeat（搜集网络流量数据）</li>
<li>2.Metricbeat（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据。）</li>
<li>3.Filebeat（搜集文件数据）</li>
<li>4.Winlogbeat（搜集 Windows 日志数据）</li>
</ul>
<blockquote>
<p>为什么用 Filebeat ，而不用原来的 Logstash 呢？</p>
</blockquote>
<p><strong>原因很简单，资源消耗比较大。</strong></p>
<p><strong>由于 Logstash 是跑在 JVM 上面，资源消耗比较大，后来作者用 GO 写了一个功能较少但是资源消耗也小的轻量级的 Agent 叫 Logstash-forwarder。</strong>后来作者加入 elastic.co 公司， Logstash-forwarder 的开发工作给公司内部 GO 团队来搞，最后命名为 Filebeat。</p>
<p>Filebeat 需要部署在每台应用服务器上。</p>
<h5 id="（1）下载"><a href="#（1）下载" class="headerlink" title="（1）下载"></a>（1）下载</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.5.4-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="（2）解压"><a href="#（2）解压" class="headerlink" title="（2）解压"></a>（2）解压</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib ~]# tar xzvf filebeat-6.5.4-linux-x86_64.tar.gz -C /usr/local/</span><br><span class="line">[root@es-3-head-kib ~]# cd /usr/local/</span><br><span class="line">[root@es-3-head-kib local]# mv filebeat-6.5.4-linux-x86_64 filebeat</span><br><span class="line">[root@es-3-head-kib local]# cd filebeat/</span><br></pre></td></tr></table></figure>

<h5 id="（3）修改配置"><a href="#（3）修改配置" class="headerlink" title="（3）修改配置"></a>（3）修改配置</h5><p>修改 Filebeat 配置，支持收集本地目录日志，并输出日志到 Kafka 集群中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib filebeat]# mv filebeat.yml filebeat.yml.bak</span><br><span class="line">[root@es-3-head-kib filebeat]# vim filebeat.yml</span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log        #指定输入的类型</span><br><span class="line">  paths:</span><br><span class="line">    -  /var/log/nginx/*.log      #日志的路径</span><br><span class="line">  json.keys_under_root: true</span><br><span class="line">  json.add_error_key: true</span><br><span class="line">  json.message_key: log</span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  hosts: [&quot;192.168.246.234:9092&quot;,&quot;192.168.246.231:9092&quot;,&quot;192.168.246.235:9092&quot;]   #kafka服务器</span><br><span class="line">  topic: &#x27;nginx&#x27;        #输出到kafka中的topic</span><br></pre></td></tr></table></figure>

<p>Filebeat 6.0 之后一些配置参数变动比较大，比如 document_type 就不支持，需要用 fields 来代替等等。</p>
<h5 id="（4）启动"><a href="#（4）启动" class="headerlink" title="（4）启动"></a>（4）启动</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@es-3-head-kib filebeat]# nohup ./filebeat -e -c filebeat.yml &amp;</span><br><span class="line">[root@es-3-head-kib filebeat]# tail -f nohup.out</span><br><span class="line">2019-08-04T16:55:54.708+0800    INFO    kafka/log.go:53    kafka message: client/metadata found some partitions to be leaderless</span><br><span class="line">2019-08-04T16:55:54.708+0800    INFO    kafka/log.go:53    client/metadata retrying after 250ms... (2 attempts remaining)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">验证kafka是否生成topic</span><br><span class="line">[root@es-3-head-kib filebeat]# cd /usr/local/kafka_2.11-2.1.0/</span><br><span class="line">[root@es-3-head-kib kafka_2.11-2.1.0]# bin/kafka-topics.sh --zookeeper 192.168.246.231:2181 --list</span><br><span class="line">__consumer_offsets</span><br><span class="line">nginx     #已经生成topic</span><br><span class="line">testtopic</span><br></pre></td></tr></table></figure>

<p><strong>现在我们去编辑logstach连接kafka的输出文件</strong></p>
<p><strong>配置完kafka之后查看</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564910479650.png" alt="1564910479650"></p>
<p>登录到kibana</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564910537485.png" alt="1564910537485"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564910581915.png" alt="1564910581915"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564910621153.png" alt="1564910621153"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564910642106.png" alt="1564910642106"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564910850500.png" alt="1564910850500"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1564910895928.png" alt="1564910895928"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">配置文件详细解释</span><br><span class="line">    https://blog.csdn.net/gamer_gyt/article/details/59077189</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">用于测试</span><br><span class="line">bin/logstash -e &#x27;input &#123; stdin&#123;&#125; &#125; output &#123;  elasticsearch &#123; hosts =&gt; [&quot;192.168.246.231:9200&quot;]&#125; &#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>ELK简易版</p>
<p><img src= "/img/loading.gif" data-lazy-src="file:///C:\Users\Administrator\AppData\Roaming\Tencent\Users\908367919\QQ\WinTemp\RichOle\YS[J4HN7T4N0L5DBHT6L_55.png" alt="img"></p>
<p>ELK终极版</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/24/ELK%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98/1571217640792.png" alt="1571217640792"></p>
]]></content>
      <categories>
        <category>ELK企业实战</category>
      </categories>
      <tags>
        <tag>ELK企业实战</tag>
      </tags>
  </entry>
  <entry>
    <title>关于git</title>
    <url>/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/</url>
    <content><![CDATA[<h2 id="一、版本控制系统"><a href="#一、版本控制系统" class="headerlink" title="一、版本控制系统"></a>一、版本控制系统</h2><h3 id="1-版本控制系统："><a href="#1-版本控制系统：" class="headerlink" title="1. 版本控制系统："></a>1. 版本控制系统：</h3><p>git   分布式  —没有中心代码库，所有机器之间的地位同等（每台机器上都有相同的代码）</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569162553917.png" alt="1569162553917"></p>
<p>svn  集中管理的 —有中心代码库，其他都是客户端</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569162546959.png" alt="1569162546959"></p>
<h3 id="2-git与svn介绍"><a href="#2-git与svn介绍" class="headerlink" title="2.git与svn介绍"></a>2.git与svn介绍</h3><h5 id="1-git属于分布式版本控制系统："><a href="#1-git属于分布式版本控制系统：" class="headerlink" title="1.git属于分布式版本控制系统："></a><strong>1.git属于</strong>分布式版本控制系统：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">客户端并不只提取最新版本的文件，而是把原始的代码仓库完整地克隆下来。</span><br><span class="line">优点：</span><br><span class="line">a.由于任何人每次提取操作，实际上都是一次对代码仓库的完整备份，因此近乎所有的操作都可以在本地执行，速度就是相当的快，并且可以在网络断开的时候操作仍然不受影响，可以频繁的进行提交更新，等到有网络的时候再上传到远程的仓库就可以了。</span><br><span class="line">b.git的分支模型，相当的轻量级，被称为“必杀技”。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">a.每个开发人员都拥有所有的代码，不利于核心代码的保密（如果有重要代码需要保密，则不建议使用git）</span><br></pre></td></tr></table></figure>

<h5 id="2-svn属于集中化的版本控制系统："><a href="#2-svn属于集中化的版本控制系统：" class="headerlink" title="2.svn属于集中化的版本控制系统："></a><strong>2.svn属于</strong>集中化的版本控制系统：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的成员通过客户端连接到这台服务器，进行文件上传和更新。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">a.使用简单，比较符合我们的常规思维</span><br><span class="line">b.同步代码比较简单，只要一步操作即可。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">a.丢失数据的风险：最显而易见的，由于集中化的特点，如果版本库的服务器磁盘发生故障等，你不能保证所有的数据已经有人提取出来了，最坏的情况是彻底的丢失整个项目的所有历史更改记录。</span><br><span class="line">b.网络中断的情况下，协作就无法进行了，因为无法连接服务器进行上传和更新。</span><br></pre></td></tr></table></figure>

<h3 id="3-git-相关概念—纯命令行"><a href="#3-git-相关概念—纯命令行" class="headerlink" title="3.git 相关概念—纯命令行"></a>3.git 相关概念—纯命令行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">工作区</span><br><span class="line">版本库</span><br><span class="line">暂存区</span><br><span class="line">HEAD</span><br><span class="line">版本号</span><br><span class="line">版本日志</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.工作区（Working Directory）</span><br><span class="line">存放git版本仓库的目录就是工作区（放源代码的地方）</span><br><span class="line"></span><br><span class="line">2.暂存区：</span><br><span class="line">Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，（会将代码添加到缓存区，没有问题之后在提交到版本库）</span><br><span class="line"></span><br><span class="line">3.版本库（Repository）</span><br><span class="line">工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</span><br><span class="line"></span><br><span class="line">4.HEAD:指向你最近一次提交后的结果。（现在是哪个版本，头就会指向这个版本）</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565333052161.png" alt="1565333052161"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1570262838271.png" alt="1570262838271"></p>
<p>1.添加文件到暂存区：</p>
<p>创建两个文件add到stage：<br>    #git add  文件名<br>    或者<br>    #git add  *</p>
<p>从暂存区(stage)提交到当前master分支的HEAD：</p>
<p>git commit -m “版本描述信息”          #提交暂存区里的修改到版本库的分支</p>
<p>版本号：最核心用的是id号。每个版本都会有一个id号，也就是commit id，</p>
<p>查看版本号：<br>    版本号可以通过版本日志查看</p>
<p>commit完成的功能类似快照，可以使用git log查看每次的commit记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vm20 gittest]# git log</span><br><span class="line">commit fbecfa3d04ae5038aa11bf55942e46c840077ace                  //id号</span><br></pre></td></tr></table></figure>

<h3 id="二、git部署"><a href="#二、git部署" class="headerlink" title="二、git部署"></a>二、git部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">环境：</span><br><span class="line">    git-server    192.168.246.214  充当中央服务器</span><br><span class="line">    client        192.168.246.213</span><br><span class="line"></span><br><span class="line">所有机器关闭防火墙和selinux</span><br><span class="line"></span><br><span class="line">安装：所有机器都安装</span><br><span class="line">   [root@git-server ~]# yum install -y git</span><br><span class="line">   [root@git-server ~]# git --version </span><br><span class="line">   git version 1.8.3.1</span><br><span class="line">   </span><br><span class="line">准备：</span><br><span class="line">    因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</span><br><span class="line">    注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置。</span><br><span class="line"></span><br><span class="line">所有的机器都添加，只要邮箱和用户不一样就可以。   </span><br><span class="line">    # git config --global user.email &quot;soho@163.com&quot;     ----设置邮箱</span><br><span class="line">    # git config --global user.name &quot;soho&quot;                   ----加添用户</span><br><span class="line">    # cat /root/.gitconfig</span><br><span class="line">    # git config --global color.ui true        #语法高亮</span><br><span class="line">    # git config --list            #查看全局配置</span><br><span class="line">    user.email=ashiyufei@aliyun.com</span><br><span class="line">    user.name=shiyufei</span><br><span class="line">    color.ui=true</span><br></pre></td></tr></table></figure>

<h4 id="1、git使用"><a href="#1、git使用" class="headerlink" title="1、git使用"></a>1、git使用</h4><p><strong>创建版本库:</strong></p>
<p>1.创建一个空目录<strong>：</strong>在中心服务器上创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server ~]# mkdir /git-test</span><br><span class="line">[root@git-server ~]# useradd git   #创建一个git用户用来运行git</span><br><span class="line">[root@git-server ~]# passwd git  #给用户设置密码</span><br><span class="line">[root@git-server ~]# cd /git-test/</span><br></pre></td></tr></table></figure>

<p>  2.通过git init命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">第1种情况：可以改代码，还能上传到别人的机器，别人也能从你这里下载但是别人不能上传代码到你的机器上。</span><br><span class="line">第2种情况：只是为了上传代码用，别人从这台机器上下载代码也可以上传代码到这台机器上，经常用于核心代码库。</span><br></pre></td></tr></table></figure>

<p><strong>创建裸库</strong>：  适用于作为远程中心仓库使用<br>创建裸库才可以从别处push（传）代码过来，使用–bare参数——裸 </p>
<h1 id="git-init-–bare-库名字"><a href="#git-init-–bare-库名字" class="headerlink" title="git init –bare  库名字"></a>git init –bare  库名字</h1><p><strong>创建一裸库</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server git-test]# git init --bare testgit</span><br><span class="line">Initialized empty Git repository in /git-test/testgit/</span><br><span class="line">[root@git-server ~]# chown git.git /git-test -R  #修改权限</span><br><span class="line">2.仓库创建完成后查看库目录：</span><br><span class="line">[root@git-server git-test]# cd testgit/</span><br><span class="line">[root@git-server testgit]# ls</span><br><span class="line">branches  config  description  HEAD  hooks  info  objects  refs</span><br></pre></td></tr></table></figure>

<h4 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.配置免密登录</span><br><span class="line">[root@client ~]# ssh-keygen    #生成秘钥</span><br><span class="line">[root@client ~]# ssh-copy-id -i git@192.168.246.214   #将秘钥传输到git服务器中的git用户</span><br><span class="line">2.克隆git仓库</span><br><span class="line">[root@client ~]# yum install -y git</span><br><span class="line">[root@client ~]# git clone git@192.168.246.214:/git-test/testgit/</span><br><span class="line">Cloning into &#x27;testgit&#x27;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br><span class="line">[root@client ~]# ls  #查看仓库已经克隆下来了</span><br><span class="line">anaconda-ks.cfg    testgit</span><br></pre></td></tr></table></figure>

<p>1.创建文件模拟代码提交到仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.在testgit目录下创建一个测试文件test.txt</span><br><span class="line">[root@client ~]# cd testgit/</span><br><span class="line">[root@client testgit]# vim test.txt   #随便写点东西</span><br><span class="line"></span><br><span class="line">2.把文件添加到暂存区：使用 &quot;git add&quot; 建立跟踪</span><br><span class="line">[root@client testgit]# git add test.txt</span><br><span class="line">注: 这里可以使用 git add * 或者 git add -A</span><br><span class="line"></span><br><span class="line">3.提交文件到仓库分支：</span><br><span class="line">[root@client testgit]# git commit -m &quot;test1&quot;</span><br><span class="line">[master (root-commit) 2b51ff9] test1</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line"> -m:描述</span><br><span class="line"> </span><br><span class="line"> 4.查看git状态：</span><br><span class="line">[root@client testgit]# git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master   <span class="comment">#分支位于master</span></span></span><br><span class="line">5.修改文件后再此查看状态：</span><br><span class="line">[root@client testgit]# echo &#x27;1122334&#x27; &gt;&gt; test.txt</span><br><span class="line">[root@client testgit]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 位于分支 master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 尚未暂存以备提交的变更：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   （使用 <span class="string">&quot;git add &lt;file&gt;...&quot;</span> 更新要提交的内容）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   （使用 <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> 丢弃工作区的改动）</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    修改：      readme.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit &quot;</span><br><span class="line">6.先add</span><br><span class="line">[root@client testgit]# git add -A</span><br><span class="line">8.再次提交commit：</span><br><span class="line">[root@client testgit]# git commit  -m &quot;add2&quot; test.txt </span><br><span class="line">[master 73bf688] add2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> [root@client testgit]# git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<h4 id="2、版本回退"><a href="#2、版本回退" class="headerlink" title="2、版本回退"></a>2、版本回退</h4><p>已经提交了不合适的修改到版本库时，想要撤销本次提交，使用版本回退，不过前提是没有推送到远程库。</p>
<p><strong>查看现在的版本：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# git log</span><br><span class="line">显示的哪个版本在第一个就是当前使用的版本。  </span><br></pre></td></tr></table></figure>

<p><strong>版本回退(切换)：</strong><br>在Git中，上一个版本就HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100（一般使用id号来恢复）</p>
<p>回到上一个版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# git reset --hard HEAD^ </span><br><span class="line">HEAD is now at 0126755 test1</span><br><span class="line">2.回到指定的版本(根据版本号): </span><br><span class="line">[root@client testgit]# git reset --hard dd66ff</span><br><span class="line">HEAD is now at dd66ff9 add2</span><br><span class="line">==========================================================</span><br><span class="line">注：消失的ID号：</span><br><span class="line">回到早期的版本后再查看git log会发现最近的版本消失，可以使用reflog查看消失的版本ID，用于回退到消失的版本</span><br><span class="line">[root@vm20 gittest]# git reflog</span><br><span class="line">2a85982 HEAD@&#123;0&#125;: reset: moving to 2a859821a2385e136fe83f3a206b287eb0eb8c18</span><br><span class="line">f5bc8c1 HEAD@&#123;1&#125;: commit: test-version2</span><br><span class="line">2a85982 HEAD@&#123;2&#125;: commit (initial): test-version1</span><br><span class="line"></span><br><span class="line">[root@git-client test_data]# git reset --hard f5bc8c1</span><br></pre></td></tr></table></figure>

<h4 id="3、删除文件"><a href="#3、删除文件" class="headerlink" title="3、删除文件"></a>3、<strong>删除文件</strong></h4><p>从工作区删除test.txt，并且从版本库一起删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">工作区：</span><br><span class="line">[root@client testgit]# touch test.txt</span><br><span class="line">[root@client testgit]# rm -rf test.txt  未添加到暂存区，可直接删除</span><br><span class="line">[root@client testgit]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">已从工作区提交到暂存区：</span><br><span class="line">第一种方法</span><br><span class="line">[root@client testgit]# touch test.txt</span><br><span class="line">[root@client testgit]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       test.txt</span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">[root@client testgit]# git add test.txt</span><br><span class="line">[root@client testgit]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   test.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"></span><br><span class="line">[root@client testgit]#  git rm --cache test.txt </span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line">[root@client testgit]# ls</span><br><span class="line">test.txt</span><br><span class="line">[root@client testgit]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       test.txt</span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">[root@client testgit]# rm -rf test.txt </span><br><span class="line">[root@client testgit]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">第二种方法：</span><br><span class="line">[root@client test_data]# touch  b.txt</span><br><span class="line">[root@client test_data]# git add b.txt </span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   b.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">[root@client test_data]# git rm -f b.txt </span><br><span class="line">rm &#x27;b.txt&#x27;</span><br><span class="line">[root@client test_data]# ls</span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line">直接在暂存区rm掉文件，如何解决</span><br><span class="line">[root@client test_data]# touch c.txt</span><br><span class="line">[root@client test_data]# git add c.txt </span><br><span class="line">[root@client test_data]# ls</span><br><span class="line">c.txt</span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   c.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">[root@client test_data]# rm -rf c.txt </span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   c.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       deleted:    c.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">[root@client test_data]# git rm --cache c.txt</span><br><span class="line">rm &#x27;c.txt&#x27;</span><br><span class="line">[root@client test_data]# ls</span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br><span class="line">[root@client test_data]# </span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure>

<h4 id="4-修改文件"><a href="#4-修改文件" class="headerlink" title="4.修改文件"></a>4.修改文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">暂存区修改名称</span><br><span class="line">[root@client test_data]# touch  a.txt</span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       a.txt</span></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line">[root@client test_data]# git add a.txt </span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   a.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">[root@client test_data]# git mv a.txt  d.txt</span><br><span class="line">[root@client test_data]# git status</span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   d.txt</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">[root@client test_data]# ls</span><br><span class="line">d.txt  test.txt</span><br><span class="line">[root@client test_data]# git rm --cache d.txt</span><br><span class="line">[root@client test_data]# rm -rf d.txt</span><br></pre></td></tr></table></figure>



<h4 id="5、将代码上传到仓库的master分支"><a href="#5、将代码上传到仓库的master分支" class="headerlink" title="5、将代码上传到仓库的master分支"></a>5、将代码上传到仓库的master分支</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# vi a.txt   #创建一个新文件</span><br><span class="line">hello world</span><br><span class="line">[root@client testgit]# git add a.txt </span><br><span class="line">[root@client testgit]# git commit -m &quot;add&quot;</span><br><span class="line">[root@client testgit]# git push origin master   #上传到中心仓库master分支</span><br><span class="line">Counting objects: 11, done.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (11/11), 828 bytes | 0 bytes/s, done.</span><br><span class="line">Total 11 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@192.168.246.214:/git-test/testgit/</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>

<p>测试:</p>
<p>在客户端将仓库删除掉然后在克隆下来查看仓库中是否有文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# cd</span><br><span class="line">[root@client ~]# rm -rf testgit/</span><br><span class="line">[root@client ~]# git clone git@192.168.246.214:/git-test/testgit/</span><br><span class="line">Cloning into &#x27;testgit&#x27;...</span><br><span class="line">remote: Counting objects: 11, done.</span><br><span class="line">remote: Compressing objects: 100% (4/4), done.</span><br><span class="line">remote: Total 11 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (11/11), done.</span><br><span class="line">[root@client ~]# cd testgit/</span><br><span class="line">[root@client testgit]# ls</span><br><span class="line">a.txt</span><br><span class="line">[root@client testgit]# cat a.txt </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<h3 id="三、创建分支并合并分支"><a href="#三、创建分支并合并分支" class="headerlink" title="三、创建分支并合并分支"></a>三、创建分支并合并分支</h3><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>在客户端操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client ~]# git clone git@192.168.246.214:/git-test/testgit/</span><br><span class="line">[root@client testgit]# git status </span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master   <span class="comment">#当前所在为master分支</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Initial commit</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">nothing to commit (create/copy files and use &quot;git add&quot; to track)</span><br><span class="line">注意：刚创建的git仓库默认的master分支要在第一次commit之后才会真正建立。然后先git add .添加所有项目文件到本地仓库缓存，再git commit -m &quot;init commit&quot;提交到本地仓库，之后就可以随心所欲地创建或切换分支了。</span><br><span class="line">创建分支:</span><br><span class="line">[root@client testgit]# git branch dev   #创建分支。</span><br><span class="line">[root@client testgit]# git branch    #查看分支。*在哪里就表示当前是哪个分支</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">切换分支:</span><br><span class="line">[root@client testgit]# git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line">[root@client testgit]# git branch </span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">在dev分支创建一个文件；</span><br><span class="line">[root@client testgit]# vi test.txt</span><br><span class="line">[root@client testgit]# git add test.txt </span><br><span class="line">[root@client testgit]# git commit -m &quot;add dev&quot;</span><br><span class="line">[dev f855bdf] add dev</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">现在，dev分支的工作完成，我们就可以切换回master分支：</span><br><span class="line"> [root@client testgit]# git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>

<p>切换回<code>master</code>分支后，再查看一个<code>test.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# ls</span><br><span class="line">a.txt</span><br></pre></td></tr></table></figure>

<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# git merge dev</span><br><span class="line">Updating 40833e0..f855bdf</span><br><span class="line">Fast-forward</span><br><span class="line"> test.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">[root@client testgit]# ls</span><br><span class="line">a.txt  test.txt</span><br><span class="line">现在已经将dev分支的内容合并到master上。确认没有问题上传到远程仓库:</span><br><span class="line">[root@client testgit]# git push origin master</span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>test.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# git branch -d dev</span><br><span class="line">Deleted branch dev (was f855bdf).</span><br></pre></td></tr></table></figure>

<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client testgit]# git branch </span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<h3 id="四、部署gitlab服务"><a href="#四、部署gitlab服务" class="headerlink" title="四、部署gitlab服务"></a>四、部署gitlab服务</h3><p>准备环境:  关闭防火墙和selinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.246.214  #gitlab服务器 </span><br></pre></td></tr></table></figure>

<p>1.配置yum源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server ~]# cd /etc/yum.repos.d/</span><br><span class="line">[root@git-server yum.repos.d]# vi gitlab-ce.repo</span><br><span class="line">[gitlab-ce]</span><br><span class="line">name=Gitlab CE Repository</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">安装相关依赖</span><br><span class="line">[root@git-server yum.repos.d]# yum install -y postfix curl policycoreutils-python openssh-server</span><br><span class="line">[root@git-server yum.repos.d]# systemctl enable sshd</span><br><span class="line">[root@git-server yum.repos.d]# systemctl start sshd</span><br><span class="line">安装postfix</span><br><span class="line">[root@git-server yum.repos.d]# yum install postfix  -y   #安装邮箱</span><br><span class="line">[root@git-server yum.repos.d]# systemctl enable postfix</span><br><span class="line">[root@git-server yum.repos.d]# systemctl start postfix</span><br><span class="line">[root@git-server yum.repos.d]# yum install -y gitlab-ce  #将会安装gitlab最新版本</span><br></pre></td></tr></table></figure>

<p>配置gitlab登录链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server ~]# vim /etc/gitlab/gitlab.rb</span><br><span class="line">1.# 添加对外的域名（gitlab.papamk.com请添加A记录指向本服务器的公网IP）：将原来的修改为</span><br><span class="line">external_url &#x27;http://192.168.246.214&#x27;</span><br><span class="line">2.设置地区</span><br><span class="line">gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565608710245.png" alt="1565608710245"></p>
<p>将数据路径的注释去掉，可以更改</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569160187589.png" alt="1569160187589"></p>
<p>开启ssh服务:</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569160284570.png" alt="1569160284570"></p>
<p>初始化Gitlab:  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server ~]# gitlab-ctl reconfigure   #重新加载，需要等很长时间</span><br></pre></td></tr></table></figure>

<p>…</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565609606025.png" alt="1565609606025"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588670665998.png" alt="1588670665998"></p>
<p>…</p>
<p>启动Gitlab服务:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server ~]# gitlab-ctl start  #启动</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565611373574.png" alt="1565611373574"></p>
<p>Gitlab 设置 HTTPS 方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果想要以上的 https 方式正常生效使用，则需要把 letsencrypt 自动生成证书的配置打开，这样在执行重</span><br><span class="line">新让配置生效命令 (gitlab-ctl reconfigure) 的时候会自动给域名生成免费的证书并自动在 gitlab 自带的</span><br><span class="line"> nginx 中加上相关的跳转配置，都是全自动的，非常方便。</span><br><span class="line">letsencrypt[&#39;enable&#39;] &#x3D; true </span><br><span class="line">letsencrypt[&#39;contact_emails&#39;] &#x3D; [&#39;caryyu@qq.com&#39;]     # 这应该是一组要添加为联系人的电子邮件地址</span><br></pre></td></tr></table></figure>

<p>测试访问:<a href="http://192.168.246.214/">http://192.168.246.214</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565623187161.png" alt="1565623187161"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565623268105.png" alt="1565623268105"></p>
<p>用户为:root</p>
<p>密码:本人设置的密码是12345678</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565623375752.png" alt="1565623375752"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565623426334.png" alt="1565623426334"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565623540821.png" alt="1565623540821"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565624343965.png" alt="1565624343965"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565623653858.png" alt="1565623653858"></p>
<p>需要创建秘钥</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1570975815122.png" alt="1570975815122"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565623702669.png" alt="1565623702669"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client ~]# ssh-keygen</span><br><span class="line">[root@client ~]# cd .ssh/</span><br><span class="line">[root@client .ssh]# ls </span><br><span class="line">[root@client .ssh]# cat id_rsa.pub </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0HeO8gaua13h9HCJK5RXVc/cjet9DpLYq2dqmQ0LXfP0Vwj6YjKxu7lE1i/4Y2cmu5lDe8bG22aikyaW38Fnz0bkGfEurdVZii/KCiHBz2lXS1ocuAdloJT4wnc2MUjh/gwc4FuNkWdYvpbMLXSSHIVjv8vB9YbHlPMTMy5N89kMwMmta5C87/8fBO5VtGijgGOueywM+xAzovlfoJbprV/ZBKkhiskSKz4fHyoGFGwllX3kMkNR/soGF5XXA+/99iO3UqSaloF0UzfUCgqfMfMVB5zDHGIB6uTrMe6ccfKp9gnVyD7m4Zmk7MwouBwAfMLIiHmvekBGXqb1YCTgJ root@client</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565624058819.png" alt="1565624058819"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565624178664.png" alt="1565624178664"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565624224328.png" alt="1565624224328"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565624437658.png" alt="1565624437658"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1570328552487.png" alt="1570328552487"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1570328571506.png" alt="1570328571506"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1570328591422.png" alt="1570328591422"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588670878842.png" alt="1588670878842"></p>
<p>创建一个文件:</p>
<p>1.newfile:先新建一个文件。<br>2.uploadfile:再上传即可。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565625483341.png" alt="1565625483341"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565625592468.png" alt="1565625592468"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565625640933.png" alt="1565625640933"></p>
<p>上传一个文件：</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588748354679.png" alt="1588748354679"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565625920395.png" alt="1565625920395"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565625940144.png" alt="1565625940144"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565625991547.png" alt="1565625991547"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626014378.png" alt="1565626014378"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626038365.png" alt="1565626038365"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626050705.png" alt="1565626050705"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626301515.png" alt="1565626301515"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626323048.png" alt="1565626323048"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626346960.png" alt="1565626346960"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626357793.png" alt="1565626357793"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1565626486555.png" alt="1565626486555"></p>
<h5 id="新建普通用户"><a href="#新建普通用户" class="headerlink" title="新建普通用户"></a>新建普通用户</h5><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569165847777.png" alt="1569165847777"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569165939543.png" alt="1569165939543"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569165986396.png" alt="1569165986396"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1569166002625.png" alt="1569166002625"></p>
<p>新添加的用户创建成功！</p>
<h5 id="在git客户端"><a href="#在git客户端" class="headerlink" title="在git客户端"></a>在git客户端</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@client ~]# git clone git@192.168.246.214:root/testapp.git</span><br><span class="line">Cloning into &#x27;testapp&#x27;...</span><br><span class="line">remote: Enumerating objects: 6, done.</span><br><span class="line">remote: Counting objects: 100% (6/6), done.</span><br><span class="line">remote: Compressing objects: 100% (4/4), done.</span><br><span class="line">remote: Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">Receiving objects: 100% (6/6), done.</span><br><span class="line">[root@client ~]# ls</span><br><span class="line">testapp</span><br><span class="line">[root@client ~]# cd testapp/</span><br><span class="line">[root@client testapp]# ls</span><br><span class="line">test.txt  同步时间.txt</span><br><span class="line">[root@client testapp]#</span><br><span class="line">使用http的</span><br><span class="line">[root@client ~]# rm -rf testgit/</span><br><span class="line">[root@client ~]# git clone http://192.168.246.214/root/testapp.git</span><br><span class="line">Cloning into &#x27;testapp&#x27;...</span><br><span class="line">Username for &#x27;http://192.168.246.214&#x27;: root</span><br><span class="line">Password for &#x27;http://root@192.168.246.214&#x27;:12345678  #为自己设置的密码</span><br><span class="line">remote: Enumerating objects: 6, done.</span><br><span class="line">remote: Counting objects: 100% (6/6), done.</span><br><span class="line">remote: Compressing objects: 100% (4/4), done.</span><br><span class="line">remote: Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (6/6), done.</span><br><span class="line">[root@client ~]# ls</span><br><span class="line">testapp</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">提交到远程gitlab仓库</span><br><span class="line">[root@client testapp]# vim update.txt</span><br><span class="line">1000phone</span><br><span class="line">[root@client testapp]# git add .</span><br><span class="line">[root@client testapp]# git commit -m &quot;update_version1&quot;</span><br><span class="line">[master 091798d] update_version1</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 update.txt</span><br><span class="line">[root@client testapp]# git push origin master</span><br><span class="line">Username for &#x27;http://192.168.62.166&#x27;: ^C</span><br><span class="line">[root@nginx-server testapp2]# git push origin master</span><br><span class="line">Username for &#x27;http://192.168.62.166&#x27;: root</span><br><span class="line">Password for &#x27;http://root@192.168.62.166&#x27;: </span><br><span class="line">Counting objects: 4, done.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 307 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To http://192.168.62.166/root/testapp2.git</span><br><span class="line">   201f479..091798d  master -&gt; master</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1570978804747.png" alt="1570978804747"></p>
<h5 id="调整上传文件的大小"><a href="#调整上传文件的大小" class="headerlink" title="调整上传文件的大小"></a>调整上传文件的大小</h5><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1571035328909.png" alt="1571035328909"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1571035355227.png" alt="1571035355227"></p>
<p>默认是10M，可根据情况调整</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1571035374378.png" alt="1571035374378"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1571035405854.png" alt="1571035405854"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">拓展：</span><br><span class="line">1.cat /proc/swaps 查看swap分区是否启动（无）</span><br><span class="line">2.创建 ：</span><br><span class="line">dd if=/dev/zero of=/data/swap bs=512 count=8388616</span><br><span class="line">创建swap大小为bs*count=4294971392(4G)；</span><br><span class="line">/data/swap目录若无则找/mnt/swap</span><br><span class="line">3.通过mkswap命令将上述空间制作成swap分区：</span><br><span class="line">mkswap /data/swap</span><br><span class="line">4.查看内核参数vm.swappiness中的数值是否为0，如果为0则根据实际需要调         整成60：</span><br><span class="line">查看： cat /proc/sys/vm/swappiness</span><br><span class="line">设置： sysctl -w vm.swappiness=60</span><br><span class="line">若想永久修改，则编辑/etc/sysctl.conf文件，改文件中有vm.swappiness变量配置，默认为0</span><br><span class="line">5.启用分区：</span><br><span class="line">swapon /data/swap</span><br><span class="line">echo “/data/swap swap swap defaults 0 0” &gt;&gt; /etc/fstab</span><br><span class="line">6.再次使用cat /proc/swaps 查看swap分区是否启动</span><br></pre></td></tr></table></figure>

<h2 id="Gitlab-备份与恢复"><a href="#Gitlab-备份与恢复" class="headerlink" title="Gitlab 备份与恢复"></a>Gitlab 备份与恢复</h2><h3 id="1、查看系统版本和软件版本"><a href="#1、查看系统版本和软件版本" class="headerlink" title="1、查看系统版本和软件版本"></a>1、查看系统版本和软件版本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server ~]# cat /etc/redhat-release </span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br><span class="line"></span><br><span class="line">[root@git-server ~]# cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</span><br><span class="line">8.15.4</span><br></pre></td></tr></table></figure>

<h3 id="2、数据备份"><a href="#2、数据备份" class="headerlink" title="2、数据备份"></a>2、数据备份</h3><p>打开/etc/gitlab/gitlab.rb配置文件，查看一个和备份相关的配置项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server backups]# vim /etc/gitlab/gitlab.rb</span><br><span class="line">gitlab_rails[&#x27;backup_path&#x27;] = &quot;/var/opt/gitlab/backups&quot;    #备份的路径</span><br><span class="line">gitlab_rails[&#x27;backup_archive_permissions&#x27;] = 0644        #备份文件的默认权限</span><br><span class="line">gitlab_rails[&#x27;backup_keep_time&#x27;] = 604800                #保留时长，秒为单位</span><br></pre></td></tr></table></figure>

<p>设置备份保留时常，防止每天执行备份，肯定有目录被爆满的风险，打开/etc/gitlab/gitlab.rb配置文件，找到如下配置</p>
<p>该项定义了默认备份出文件的路径，可以通过修改该配置，并执行 <strong>gitlab-ctl reconfigure 或者 gitlab-ctl  restart</strong> 重启服务生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server backups]# gitlab-ctl reconfigure</span><br><span class="line">或者</span><br><span class="line">[root@git-server backups]# gitlab-ctl  restart</span><br></pre></td></tr></table></figure>

<p>执行备份命令进行备份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server backups]# /opt/gitlab/bin/gitlab-rake gitlab:backup:create </span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588671804467.png" alt="1588671804467"></p>
<p>也可以添加到 crontab 中定时执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure>

<p>可以到/data/gitlab/backups找到备份包，解压查看，会发现备份的还是比较全面的，数据库、repositories、build、upload等分类还是比较清晰的。</p>
<p>备份完成，会在备份目录中生成一个当天日期的tar包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server ~]# ll /var/opt/gitlab/backups/</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588674873071.png" alt="1588674873071"></p>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>特别注意：</p>
<ul>
<li>备份目录和gitlab.rb中定义的备份目录必须一致</li>
<li>GitLab的版本和备份文件中的版本必须一致，否则还原时会报错。</li>
</ul>
<p><strong>在恢复之前，可以删除一个文件，以便查看效果</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588671953485.png" alt="1588671953485"></p>
<p>执行恢复操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@git-server  backups]# gitlab-rake gitlab:backup:restore BACKUP=1588700546_2020_05_06_12.6.3</span><br><span class="line">注意恢复文件的名称</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588672033757.png" alt="1588672033757"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588672066970.png" alt="1588672066970"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588672081738.png" alt="1588672081738"></p>
<p>恢复完成后，启动刚刚的两个服务，或者重启所有服务，再打开浏览器进行访问，发现数据和之前的一致：</p>
<p><strong>注意：通过备份文件恢复gitlab必须保证两台主机的gitlab版本一致，否则会提示版本不匹配</strong></p>
<p>查看gitlab端，可以看到数据恢复成功</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588754052558.png" alt="1588754052558"></p>
<h2 id="Github-远程仓库"><a href="#Github-远程仓库" class="headerlink" title="Github 远程仓库"></a>Github 远程仓库</h2><p>1、github.com 注册账户</p>
<p>2、在github上创建仓库</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588673609788.png" alt="1588673609788"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588673721676.png" alt="1588673721676"></p>
<p>3、客户端生成本地ssh key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ssh-keygen -t rsa -C &#x27;meteor@163.com&#x27; # 邮箱要与github上注册的相同</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:RiE6UR1BtzV5avyE2uz6TNPsVHa2D2eHprghrJEkd/g meteor@163.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|    ..oo=o. o.   |</span><br><span class="line">|     o ..o o...  |</span><br><span class="line">|    o   . .. +   |</span><br><span class="line">|     . o    = .  |</span><br><span class="line">|    . + S  = o  =|</span><br><span class="line">|     + *  . oo.=o|</span><br><span class="line">|      o E ..o B.+|</span><br><span class="line">|       o . =.* +o|</span><br><span class="line">|      .   +++ . .|</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line">[root@localhost ~]#</span><br><span class="line">[root@localhost ~]# cat .ssh/id_rsa.pub </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDVThfq4brrlsPGtAknVB0TLPx+7Dd3qlxTbSIrUOsGC5Y8JuNqVTlIntZB4oNj8cSQrWvec9CKm0a8o7WwaJIiqpxurz+YpQHP2KbapftKIxsX4hPf/z+p0El1U6arQa35/xmNsq+cJLH/bDdRG+EMDhuCBmjVZOlLj/hEdeIT6s56AnnCkaWoF+sq58KCF7Tk54jRbs/YiyE4SN7FuA70r+07sA/uj0+lmuk4E190KtQUELhjX/E9stivlqiRhxnKvVUqXDywsjfM8Rtvbi4Fg9R8Wt9fpd4QwnWksYUoR5qZJFYXO4hSZrUnSMruPK14xXjDJcFDcP2eHIzKgLD1 meteor@163.com</span><br></pre></td></tr></table></figure>

<p>4、复制以上的公钥，在github 中添加ssh key</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588673639512.png" alt="1588673639512"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588673667402.png" alt="1588673667402"></p>
<p>创建好库之后，在库里创建几个文件，方便测试</p>
<p>5、测试：拉取github仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum install git</span><br><span class="line">[root@localhost ~]# git config --global user.name &#x27;meteor_by&#x27;</span><br><span class="line">[root@localhost ~]# git config --global user.email &#x27;meteor@163.com&#x27;</span><br><span class="line">[root@localhost tmp]# cd /tmp</span><br><span class="line">[root@localhost tmp]# git clone git@github.com:youngfit/youngfit.git</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588673833960.png" alt="1588673833960"></p>
<p>7、在本地添加远程仓库，并推送至github仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# cd /tmp/youngfit/</span><br><span class="line">[root@localhost youngfit]# ls</span><br><span class="line">qf.txt  README.md</span><br><span class="line">[root@localhost youngfit]# cat qf.txt </span><br><span class="line">this is 2001 test file</span><br><span class="line">[root@client youngfit]# ls</span><br><span class="line">qf.txt  README.md</span><br><span class="line">[root@localhost youngfit]# vim a.txt</span><br><span class="line">[root@localhost youngfit]# git add .</span><br><span class="line">[root@localhost youngfit]# git commit -m &quot;yufei&quot;</span><br><span class="line">[master 0f6a3de] yufei</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 a.txt</span><br><span class="line">[root@client youngfit]# git push origin master</span><br><span class="line">Counting objects: 4, done.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 288 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:youngfit/youngfit.git</span><br><span class="line">   ba8225d..0f6a3de  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>去githun界面查看</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588674573283.png" alt="1588674573283"></p>
<p>8、连接远程仓库听方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">[root@localhost testapp]<span class="comment"># git remote -v </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">origin    git@github.com:meteor/python1804.git (fetch)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">origin    git@github.com:meteor/python1804.git (push)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">[root@localhost python1804]<span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">[root@localhost python1804]<span class="comment">#  git remote rm origin  (如果连接远程的方式不是ssh,可以删除重新添加)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">[root@localhost ~]<span class="comment"># git remote add origin git@github.com:meteor/python1804.git</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line"><span class="meta">#</span><span class="bash">git remote add origin https://github.com/meteor/python1804.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash">git push -u origin master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@client youngfit]# git remote -v</span><br><span class="line">origin  git@github.com:youngfit/youngfit.git (fetch)</span><br><span class="line">origin  git@github.com:youngfit/youngfit.git (push)</span><br><span class="line">[root@client youngfit]# git remote rm origin</span><br><span class="line">[root@client youngfit]# git remote add origin git@192.168.62.131:root/testapp.git</span><br><span class="line">[root@client youngfit]# ls</span><br><span class="line">a.txt  qf.txt  README.md</span><br><span class="line">[root@client youngfit]# pwd</span><br><span class="line"></span><br><span class="line">[root@client ~]# cd /root/testapp/</span><br><span class="line">[root@client testapp]# ls</span><br><span class="line">test.sql  test.txt  update.txt</span><br><span class="line">[root@client testapp]# vim modify.txt</span><br><span class="line">[root@client testapp]# git add .</span><br><span class="line">[root@client testapp]# git commit -m &quot;modify gitlab from github&quot;</span><br><span class="line">[master fde12c2] modify gitlab from github</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 modify.txt</span><br><span class="line"></span><br><span class="line">[root@client testapp]# git push origin master</span><br><span class="line">Username for &#x27;http://192.168.62.131&#x27;: root</span><br><span class="line">Password for &#x27;http://root@192.168.62.131&#x27;: </span><br><span class="line">Counting objects: 4, done.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 337 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To http://192.168.62.131/root/testapp.git</span><br><span class="line">   23bae45..fde12c2  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>去自己部署的gitlab上查看</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/22/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/1588674319140.png" alt="1588674319140"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>关于git</category>
      </categories>
      <tags>
        <tag>关于git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下网易云无视版权，会员等歌曲</title>
    <url>/2020/08/22/%E4%BD%BF%E7%94%A8UnblockNeteaseMusic%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E7%89%88%E6%9D%83%E6%AD%8C%E6%9B%B2/</url>
    <content><![CDATA[<h1 id="使用UnblockNeteaseMusic播放网易云音乐客户端无版权歌曲"><a href="#使用UnblockNeteaseMusic播放网易云音乐客户端无版权歌曲" class="headerlink" title="使用UnblockNeteaseMusic播放网易云音乐客户端无版权歌曲"></a>使用UnblockNeteaseMusic播放网易云音乐客户端无版权歌曲</h1><h3 id="linux下yum安装node和npm，git"><a href="#linux下yum安装node和npm，git" class="headerlink" title="linux下yum安装node和npm，git"></a>linux下yum安装node和npm，git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install nodejs -y</span><br><span class="line">yum install git -y</span><br></pre></td></tr></table></figure>

<h3 id="运行UnblockNeteaseMusic"><a href="#运行UnblockNeteaseMusic" class="headerlink" title="运行UnblockNeteaseMusic"></a>运行UnblockNeteaseMusic</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;nondanee&#x2F;UnblockNeteaseMusic.git</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd UnblockNeteaseMusic</span><br><span class="line">node app.js 或者 node app.js &amp; &lt;两下回车放后台&gt;</span><br></pre></td></tr></table></figure>

<p>云主机下 后台启动 {全天}:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g forever</span><br><span class="line">forever start app.js -p 10010 &#x2F;&#x2F;放后台运行</span><br></pre></td></tr></table></figure>

<h3 id="开机自启脚本，服务"><a href="#开机自启脚本，服务" class="headerlink" title="开机自启脚本，服务"></a>开机自启脚本，服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;UnblockNeteaseMusic.service &lt;&lt;EOF</span><br></pre></td></tr></table></figure>

<p>[Unit]<br>Description=UnblockNeteaseMusic<br>After=network.target<br>Wants=network.target</p>
<p>[Service]<br>Type=simple<br>PIDFile=/var/run/UnblockNeteaseMusic.pid<br>WorkingDirectory=/home/UnblockNeteaseMusic<br>ExecStart=$(command -v node) app.js<br>RestartPreventExitStatus=23<br>Restart=always</p>
<p>[Install]<br>WantedBy=multi-user.target<br>EOF</p>
<h3 id="这里可以自定义端口"><a href="#这里可以自定义端口" class="headerlink" title="这里可以自定义端口"></a>这里可以自定义端口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node app.js -p 端口号</span><br></pre></td></tr></table></figure>

<h3 id="运行脚本并开机自启"><a href="#运行脚本并开机自启" class="headerlink" title="运行脚本并开机自启"></a>运行脚本并开机自启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start UnblockNeteaseMusic</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable UnblockNeteaseMusic</span><br></pre></td></tr></table></figure>

<p>注：要关闭防火墙 systemctl stop firewalld</p>
<p>setenforce 0  关闭selinux</p>
<p>网易云代理设置方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">网易云客户端设置 &gt; 工具 &gt; 自定义代理 &gt; HTTP代理</span><br><span class="line">这里只需要填上你的服务器ip和端口，保存即可。</span><br><span class="line">Windows</span><br><span class="line">设置&gt;工具&gt;自定义代理(客户端内)</span><br><span class="line">UWP</span><br><span class="line">Windows设置&gt;网络和Internet &gt;代理</span><br><span class="line">Linux</span><br><span class="line">系统设置&gt;网络&gt;网络代理</span><br><span class="line">macOS</span><br><span class="line">系统偏好设置&gt;网络&gt;高级&gt;代理</span><br><span class="line">Android</span><br><span class="line">WLAN&gt;修改网络&gt;高级选项&gt;代理</span><br><span class="line">iOs</span><br><span class="line">#设置方法</span><br><span class="line">需要用到代理配置工具 Shadowrocket （拼夕夕几块钱）</span><br><span class="line">打开小火箭 &gt; 添加节点(类型选择HTTP，输入你的ip和端口，随便备注下，右上角完成即可) &gt; 编辑配置 &gt; 添加规则(类型选择USER-AGENT，选项选择网易云，用户代理输入NeteaseMusic*)，保存即可。</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>inux下网易云无视版权，会员等歌曲</category>
      </categories>
      <tags>
        <tag>inux下网易云无视版权，会员等歌曲</tag>
      </tags>
  </entry>
</search>
